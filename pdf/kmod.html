<h1 id="kmod-linux内核模块工具">kmod-Linux内核模块工具</h1>
<h2 id="项目背景分析">1. 项目背景分析</h2>
<p>kmod 是为了能够操作 Linux 内核模块而推出的一系列工具集，这些操作包括 插入（insert），删除（remove），列出（list），检查属性（check properties）和解决依赖关系（dependencies）。</p>
<p>这些工具在底层都需要用到 libkmod 这个库，相关的源码也会跟着 kmod 项目一同发布。这个项目的目标是能够实现与在此之前 module-init-tools 项目所提供的工具兼容。</p>
<h3 id="项目建立时间">项目建立时间</h3>
<p>从 git.kernel.org 上的 commit log 分析，该项目的建立时间是 2011-11-21。最初的项目是通过继承了 libabc 的框架开始逐步演变而来。2011-12-15 发布了 kmod 1 版本。</p>
<p>参考<em>项目主页</em><br /><a href="http://git.kernel.org/cgit/utils/kernel/kmod/kmod.git"><code class="url">http://git.kernel.org/cgit/utils/kernel/kmod/kmod.git</code></a></p>
<h3 id="项目创建者和维护者">项目创建者和维护者</h3>
<p>创建者是 Lucas De Marchi。这个人就职于巴西 Brazil Campinas 的一家公司ProFUSION Embedded Systems（该公司的主页http://profusion.mobi/），从他在 github 个人项目的帐号创建时间看是 2008年10月30号，应该是属于比较早期的 github 用户。</p>
<p>参考<em>个人主页</em><br /><a href="https://github.com/lucasdemarchi"><code class="url">https://github.com/lucasdemarchi</code></a></p>
<h3 id="项目更新记录">项目更新记录</h3>
<p>项目最近一次提交 commit log 表明，该项目近期处于一个比较活跃的状态。从 2013-4-9 发布了最新的 kmod 13 版本之后，该项目几乎每隔1，2天有一次或多次提交。最近的一次提交是 2013-4-17，主要的贡献者仍然是 Lucas De Marchi。</p>
<p>参考<em>提交记录</em><br /><a href="http://git.kernel.org/cgit/utils/kernel/kmod/kmod.git/log/"><code class="url">http://git.kernel.org/cgit/utils/kernel/kmod/kmod.git/log/</code></a></p>
<h3 id="项目版本情况">项目版本情况</h3>
<p>第一个可以下载的软件包 kmod-1.tar.gz 是2012-2-24 上传的，最新的软件包 kmod-13.tar.gz 是 2013-4-9 上传的。</p>
<p>目前 kmod 已经发布到了第13个版本，从项目 NEWS 中可以看到，项目从版本 1 就开始支持原来的 insmod/rmmod/lsmod/modprobe 这几个常用命令，发展至今libkmod 库已经提供了100多个函数接口用于方便用户管理内核模块。</p>
<h3 id="项目资源汇总">项目资源汇总</h3>
<ul>
<li><p>代码下载<br /> <a href="https://www.kernel.org/pub/linux/utils/kernel/kmod"><code class="url">https://www.kernel.org/pub/linux/utils/kernel/kmod</code></a></p></li>
<li><p>邮件列表<br /> <script type="text/javascript">
<!--
h='&#118;&#x67;&#x65;&#114;&#46;&#x6b;&#x65;&#114;&#110;&#x65;&#108;&#46;&#x6f;&#114;&#x67;';a='&#64;';n='&#108;&#x69;&#110;&#x75;&#120;&#x2d;&#x6d;&#x6f;&#100;&#x75;&#108;&#x65;&#x73;';e=n+a+h;
document.write('<a h'+'ref'+'="ma'+'ilto'+':'+e+'">'+'<code>'+e+'</code>'+'<\/'+'a'+'>');
// -->
</script><noscript>&#108;&#x69;&#110;&#x75;&#120;&#x2d;&#x6d;&#x6f;&#100;&#x75;&#108;&#x65;&#x73;&#32;&#x61;&#116;&#32;&#118;&#x67;&#x65;&#114;&#32;&#100;&#x6f;&#116;&#32;&#x6b;&#x65;&#114;&#110;&#x65;&#108;&#32;&#100;&#x6f;&#116;&#32;&#x6f;&#114;&#x67;</noscript></p></li>
<li><p>Git项目仓库<br /> git://git.kernel.org/pub/scm/utils/kernel/kmod/kmod.git<br /> <a href="https://git.kernel.org/pub/scm/utils/kernel/kmod/kmod.git"><code class="url">https://git.kernel.org/pub/scm/utils/kernel/kmod/kmod.git</code></a></p></li>
<li><p>Gitweb页面<br /> <a href="http://git.kernel.org/?p=utils/kernel/kmod/kmod.git"><code class="url">http://git.kernel.org/?p=utils/kernel/kmod/kmod.git</code></a></p></li>
</ul>
<h2 id="项目技术分析">2. 项目技术分析</h2>
<h3 id="开发环境准备">开发环境准备</h3>
<ul>
<li>首先需要安装如下的软件工具
<ul>
<li>GCC compiler 编译工具</li>
<li>GNU C library 标准C库</li>
<li>autoconf 自动化配置工具，可以生成项目所需的 makefile</li>
<li>shtool 一个兼容之前类似 mkdir.sh/install.sh 的shell脚本工具</li>
<li>libtool 制作可生成依赖关系的共享库，生成文件后缀名为 .la, lo</li>
<li>xsltproc 快速XSLT引擎，可以通过XSL层叠样式表把XML转换为其他格式，例如html/pdf</li>
</ul></li>
<li>可选的依赖关系:
<ul>
<li>ZLIB library</li>
<li>LZMA library</li>
</ul></li>
</ul>
<h3 id="编译和安装">编译和安装</h3>
<pre><code>$ sudo apt-get install autoconf 
$ sudo apt-get install shtool 
$ sudo apt-get install libtool
$ sudo apt-get install xsltproc 

$ aclocal
$ autoconf
$ ./configure CFLAGS=&quot;-g -O2&quot; --prefix=/usr --sysconfdir=/etc --libdir=/usr/lib
$ make &amp;&amp; make install</code></pre>
<h3 id="错误及解决">错误及解决</h3>
<p>代码编译过程会出现不少问题，但都可以通过安装和配置逐一解决。现对编译过程中的问题做一总结：</p>
<p><strong>1）autoconf 缺少环境变量文件</strong></p>
<pre><code>$ autoconf 
configure.ac:10: error: possibly undefined macro: AM_INIT_AUTOMAKE
      If this token and others are legitimate, please use m4_pattern_allow.
      See the Autoconf documentation.
configure.ac:28: error: possibly undefined macro: AM_PROG_CC_C_O
configure.ac:89: error: possibly undefined macro: AM_CONDITIONAL
$ aclocal</code></pre>
<p>通过 aclocal 命令生成，获取当前系统的环境变量，生成一个 aclocal.m4 文件。</p>
<p><strong>2）configure 脚本执行时缺少 libtool 工具</strong></p>
<pre><code>$ ./configure CFLAGS=&quot;-g -O2&quot; --prefix=/usr --sysconfdir=/etc --libdir=/usr/lib
configure: error: cannot find install-sh, install.sh, or shtool in build-aux &quot;.&quot;/build-aux
$ autoreconf -f -i -Wall,no-obsolete
Can&#39;t exec &quot;libtoolize&quot;: No such file or directory at /usr/bin/autoreconf line 196.
Use of uninitialized value in pattern match (m//) at /usr/bin/autoreconf line 196.
$ sudo apt-get install libtool</code></pre>
<p>通过 sudo apt-get 安装解决。</p>
<p><strong>3）configuire 脚本执行缺少 xsltproc 命令</strong></p>
<pre><code>$ ./configure CFLAGS=&quot;-g -O2&quot; --prefix=/usr --sysconfdir=/etc --libdir=/usr/lib
configure: error: xsltproc command not found, try ./configure --disable-manpages
$ sudo apt-get install xsltproc </code></pre>
<p>通过 sudo apt-get 安装解决，成功之后，会在当前目录下生成 Makefile 文件。</p>
<h3 id="编译过程">编译过程</h3>
<p>编译过程总体比较顺利，执行 make 和 make install 命令即可完成。</p>
<pre><code>$ make
make --no-print-directory all-recursive
Making all in .
  CC     libkmod/libkmod.lo
  CC     libkmod/libkmod-list.lo
  CC     libkmod/libkmod-config.lo
  CC     libkmod/libkmod-index.lo
  CC     libkmod/libkmod-module.lo
  CC     libkmod/libkmod-file.lo
  CC     libkmod/libkmod-elf.lo
  CC     libkmod/libkmod-signature.lo
  CC     libkmod/libkmod-hash.lo
  CC     libkmod/libkmod-array.lo
  CC     libkmod/libkmod-util.lo
  CCLD   libkmod/libkmod-util.la
  CCLD   libkmod/libkmod.la
  CCLD   libkmod/libkmod-private.la
  CC     tools/kmod.o
  CC     tools/lsmod.o
  CC     tools/rmmod.o
  CC     tools/insmod.o
  CC     tools/modinfo.o
  CC     tools/modprobe.o
  CC     tools/depmod.o
  CC     tools/log.o
  CC     tools/static-nodes.o
  CCLD   tools/kmod
  CCLD   tools/kmod-nolib
  GEN    tools/insmod
  GEN    tools/rmmod
  GEN    tools/lsmod
  GEN    tools/modprobe
  GEN    tools/modinfo
  GEN    tools/depmod
  GEN    libkmod/libkmod.pc
Making all in libkmod/docs
make[2]: Nothing to be done for `all&#39;.
Making all in man
  GEN    depmod.d.5
  GEN    modprobe.d.5
  GEN    modules.dep.5
  GEN    depmod.8
  GEN    insmod.8
  GEN    lsmod.8
  GEN    rmmod.8
  GEN    modprobe.8
  GEN    modinfo.8</code></pre>
<p>由以上编译过程可知，项目主要架构分为2层，上层为 tools 目录下提供的各种工具（兼容之前的命令集，例如 insmod/rmmod），下层为 libkmod 目录下生成的 libkmod.la，为上层工具提供所需要的库函数。</p>
<h3 id="生成文件">生成文件</h3>
<pre><code>$ ls tools/ -l | grep x
lrwxrwxrwx 1 akaedu akaedu     10 Apr 17 04:43 depmod -&gt; kmod-nolib
lrwxrwxrwx 1 akaedu akaedu     10 Apr 17 04:43 insmod -&gt; kmod-nolib
-rwxrwxr-x 1 akaedu akaedu   8385 Apr 17 04:43 kmod
-rwxrwxr-x 1 akaedu akaedu 488644 Apr 17 04:43 kmod-nolib
lrwxrwxrwx 1 akaedu akaedu     10 Apr 17 04:43 lsmod -&gt; kmod-nolib
lrwxrwxrwx 1 akaedu akaedu     10 Apr 17 04:43 modinfo -&gt; kmod-nolib
lrwxrwxrwx 1 akaedu akaedu     10 Apr 17 04:43 modprobe -&gt; kmod-nolib
lrwxrwxrwx 1 akaedu akaedu     10 Apr 17 04:43 rmmod -&gt; kmod-nolib</code></pre>
<p>可以看出以上所有工具，均是 kmod-nolib 的软链接。实现了一个 kmod-nolib 程序，也就实现了之前的各种工具。 这种实现思路，类似于嵌入式开发中的 busybox 项目，也是实现了一堆工具，但只有一个真正的可执行文件。</p>
<pre><code>$ ls libkmod/ -l | grep lo 
-rw-rw-r-- 1 akaedu akaedu   308 Apr 17 04:43 libkmod-array.lo
-rw-rw-r-- 1 akaedu akaedu   310 Apr 17 04:43 libkmod-config.lo
-rw-rw-r-- 1 akaedu akaedu   304 Apr 17 04:43 libkmod-elf.lo
-rw-rw-r-- 1 akaedu akaedu   306 Apr 17 04:43 libkmod-file.lo
-rw-rw-r-- 1 akaedu akaedu   306 Apr 17 04:43 libkmod-hash.lo
-rw-rw-r-- 1 akaedu akaedu   308 Apr 17 04:43 libkmod-index.lo
-rw-rw-r-- 1 akaedu akaedu   306 Apr 17 04:43 libkmod-list.lo
-rw-rw-r-- 1 akaedu akaedu   296 Apr 17 04:43 libkmod.lo
-rw-rw-r-- 1 akaedu akaedu   310 Apr 17 04:43 libkmod-module.lo
-rw-rw-r-- 1 akaedu akaedu   316 Apr 17 04:43 libkmod-signature.lo
-rw-rw-r-- 1 akaedu akaedu   306 Apr 17 04:43 libkmod-util.lo</code></pre>
<p>上面所列的 lo 文件中，libkmod-module.lo 中包含了在整个库中，最靠近上层调用所需要用的接口函数。其他的 lo 文件基本上都是为 libkmod-module.lo 所服务的，比较重要的例如 libkmod-elf, libkmod-file, libkmod-list 等。</p>
<pre><code>$ ls libkmod/ -l | grep la
-rw-rw-r-- 1 akaedu akaedu   923 Apr 17 04:43 libkmod.la
-rw-rw-r-- 1 akaedu akaedu   893 Apr 17 04:43 libkmod-private.la
-rw-rw-r-- 1 akaedu akaedu   884 Apr 17 04:43 libkmod-util.la</code></pre>
<p>最终提供的库文件是以 libkmod.la 的形式存在。</p>
<pre><code>$ ls libkmod/ -l | grep pc
-rw-rw-r-- 1 akaedu akaedu   210 Apr 17 04:43 libkmod.pc
-rw-rw-r-- 1 akaedu akaedu   255 Apr 17 00:53 libkmod.pc.in</code></pre>
<p>此文件暂时没看出有什么特殊的作用，只包含了一些对当前库的说明信息，是一个纯文本文件。</p>
<h3 id="安装过程">安装过程</h3>
<pre><code>$ make &amp;&amp; make install
make --no-print-directory all-recursive
Making all in .
Making all in libkmod/docs
make[2]: Nothing to be done for `all&#39;.
Making all in man
make[2]: Nothing to be done for `all&#39;.
Making install in .
test -z &quot;/usr/lib&quot; || /bin/mkdir -p &quot;/usr/lib&quot;
 /bin/bash ./libtool   --mode=install /usr/bin/install -c   libkmod/libkmod.la &#39;/usr/lib&#39;
libtool: install: /usr/bin/install -c libkmod/.libs/libkmod.so.2.2.3 /usr/lib/libkmod.so.2.2.3
/usr/bin/install: cannot create regular file `/usr/lib/libkmod.so.2.2.3&#39;: Permission denied
make[2]: *** [install-libLTLIBRARIES] Error 1
make[1]: *** [install-am] Error 2
make: *** [install-recursive] Error 1</code></pre>
<p>编译过程中，因为需要用到对 /usr/bin 目录的读写权限，因此需要用 sudo 来执行。</p>
<pre><code>$ sudo make install
Making install in .
test -z &quot;/usr/lib&quot; || /bin/mkdir -p &quot;/usr/lib&quot;
 /bin/bash ./libtool   --mode=install /usr/bin/install -c   libkmod/libkmod.la &#39;/usr/lib&#39;
libtool: install: /usr/bin/install -c libkmod/.libs/libkmod.so.2.2.3 /usr/lib/libkmod.so.2.2.3
libtool: install: (cd /usr/lib &amp;&amp; { ln -s -f libkmod.so.2.2.3 libkmod.so.2 || { rm -f libkmod.so.2 &amp;&amp; ln -s libkmod.so.2.2.3 libkmod.so.2; }; })
libtool: install: (cd /usr/lib &amp;&amp; { ln -s -f libkmod.so.2.2.3 libkmod.so || { rm -f libkmod.so &amp;&amp; ln -s libkmod.so.2.2.3 libkmod.so; }; })
libtool: install: /usr/bin/install -c libkmod/.libs/libkmod.lai /usr/lib/libkmod.la
libtool: finish: PATH=&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/sbin&quot; ldconfig -n /usr/lib
----------------------------------------------------------------------
Libraries have been installed in:
   /usr/lib

If you ever happen to want to link against installed libraries
in a given directory, LIBDIR, you must either use libtool, and
specify the full pathname of the library, or use the `-LLIBDIR&#39;
flag during linking and do at least one of the following:
   - add LIBDIR to the `LD_LIBRARY_PATH&#39; environment variable
     during execution
   - add LIBDIR to the `LD_RUN_PATH&#39; environment variable
     during linking
   - use the `-Wl,-rpath -Wl,LIBDIR&#39; linker flag
   - have your system administrator add LIBDIR to `/etc/ld.so.conf&#39;

See any operating system documentation about shared libraries for
more information, such as the ld(1) and ld.so(8) manual pages.
----------------------------------------------------------------------
test -z &quot;/usr/bin&quot; || /bin/mkdir -p &quot;/usr/bin&quot;
  /bin/bash ./libtool   --mode=install /usr/bin/install -c tools/kmod &#39;/usr/bin&#39;
libtool: install: /usr/bin/install -c tools/.libs/kmod /usr/bin/kmod
make --no-print-directory install-exec-hook
if test &quot;/usr/lib&quot; != &quot;/usr/lib&quot;; then \
        /bin/mkdir -p /usr/lib &amp;&amp; \
        so_img_name=$(readlink /usr/lib/libkmod.so) &amp;&amp; \
        so_img_rel_target_prefix=$(echo /usr/lib | sed &#39;s,\(^/\|\)[^/][^/]*,..,g&#39;) &amp;&amp; \
        ln -sf $so_img_rel_target_prefix/usr/lib/$so_img_name /usr/lib/libkmod.so &amp;&amp; \
        mv /usr/lib/libkmod.so.* /usr/lib; \
    fi
test -z &quot;/usr/include&quot; || /bin/mkdir -p &quot;/usr/include&quot;
 /usr/bin/install -c -m 644 libkmod/libkmod.h &#39;/usr/include&#39;
test -z &quot;/usr/lib/pkgconfig&quot; || /bin/mkdir -p &quot;/usr/lib/pkgconfig&quot;
 /usr/bin/install -c -m 644 libkmod/libkmod.pc &#39;/usr/lib/pkgconfig&#39;
Making install in libkmod/docs
make[2]: Nothing to be done for `install-exec-am&#39;.
make[2]: Nothing to be done for `install-data-am&#39;.
Making install in man
make[2]: Nothing to be done for `install-exec-am&#39;.
test -z &quot;/usr/share/man/man5&quot; || /bin/mkdir -p &quot;/usr/share/man/man5&quot;
 /usr/bin/install -c -m 644 depmod.d.5 modprobe.d.5 modules.dep.5 modules.dep.bin.5 &#39;/usr/share/man/man5&#39;
test -z &quot;/usr/share/man/man8&quot; || /bin/mkdir -p &quot;/usr/share/man/man8&quot;
 /usr/bin/install -c -m 644 depmod.8 insmod.8 lsmod.8 rmmod.8 modprobe.8 modinfo.8 &#39;/usr/share/man/man8&#39;
$ sudo make install</code></pre>
<p>这个 make 和 make install 的过程，帮助我们理清了哪些文件参与最后的编译生成过程。特别是对于最后 make install 的执行分析，也让我们了解了项目最终要实现的目标和生成的重要文件。以下将对这一过程展开详细分析。</p>
<h3 id="安装文件">安装文件</h3>
<pre><code>$ ls /usr/lib/libkmod.so
libkmod.so        libkmod.so.2      libkmod.so.2.2.3  
$ ls /usr/lib/libkmod.so* -l
lrwxrwxrwx 1 root root     16 Apr 17 04:55 /usr/lib/libkmod.so -&gt; libkmod.so.2.2.3
lrwxrwxrwx 1 root root     16 Apr 17 04:55 /usr/lib/libkmod.so.2 -&gt; libkmod.so.2.2.3
-rwxr-xr-x 1 root root 313349 Apr 17 04:55 /usr/lib/libkmod.so.2.2.3</code></pre>
<p>libkmod.so 是一个软链接，安装在系统的 /usr/lib 目录下，链接的时候只需要指定 -lkmod 就可以。</p>
<pre><code>$ ls /usr/lib/libkmod.l* -l
-rwxr-xr-x 1 root root 924 Apr 17 04:55 /usr/lib/libkmod.la

$ ls /usr/lib/libkmod.* -l
-rwxr-xr-x 1 root root    924 Apr 17 04:55 /usr/lib/libkmod.la
lrwxrwxrwx 1 root root     16 Apr 17 04:55 /usr/lib/libkmod.so -&gt; libkmod.so.2.2.3
lrwxrwxrwx 1 root root     16 Apr 17 04:55 /usr/lib/libkmod.so.2 -&gt; libkmod.so.2.2.3
-rwxr-xr-x 1 root root 313349 Apr 17 04:55 /usr/lib/libkmod.so.2.2.3</code></pre>
<p>真正起作用的 so 文件，也就是 libkmod 共享库的 real name 是 libkmod.so.2.2.3。</p>
<pre><code>$ ls /usr/bin/kmod  -l
-rwxr-xr-x 1 root root 233584 Apr 17 04:55 /usr/bin/kmod
$ file /usr/bin/kmod
/usr/bin/kmod: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.24, BuildID[sha1]=0x9d4131d1eb78b1e1852cc5ad44f06417ae3caa3c, not stripped
$ kmod
missing command
kmod - Manage kernel modules: list, load, unload, etc
Usage:
    kmod [options] command [command_options]

Options:
    -V, --version     show version
    -h, --help        show this help

Commands:
  help         Show help message
  list         list currently loaded modules
  static-nodes outputs the static-node information installed with the currently running kernel

kmod also handles gracefully if called from following symlinks:
  lsmod        compat lsmod command
  rmmod        compat rmmod command
  insmod       compat insmod command
  modinfo      compat modinfo command
  modprobe     compat modprobe command
  depmod       compat depmod command</code></pre>
<p>kmod 是一个工具，可以实现内核模块的 list 和 打印输出已经被加载的内核模块的详细信息。</p>
<pre><code>$ ls /usr/include/libkmod.h -l
-rw-r--r-- 1 root root 9429 Apr 17 04:55 /usr/include/libkmod.h
$ 文件内容见下面小节</code></pre>
<p>头文件是最重要的生成文件，会被之后所有调用 libkmod 库的上层应用所包含。一个文件就包含了所有需要用的函数接口声明，使用起来也非常方便。只不过这个文件中包含了较多的函数，互相之间不是平行的，内部是有上下层次关系的。</p>
<pre><code>$ ls /usr/lib/pkgconfig/libkmod.pc -l
-rw-r--r-- 1 root root 210 Apr 17 04:55 /usr/lib/pkgconfig/libkmod.pc
$ cat /usr/lib/pkgconfig/libkmod.pc 
prefix=/usr
exec_prefix=/usr
libdir=/usr/lib
includedir=/usr/include

Name: libkmod
Description: Library to deal with kernel modules
Version: 13
Libs: -L${libdir} -lkmod
Libs.private:  
Cflags: -I${includedir}
$ </code></pre>
<p>这个文件只是一个纯文本文件，里面包含了如上所列出的信息。</p>
<pre><code>$ ls /usr/share/man/man5/ -l | grep &quot;Apr 17&quot;
-rw-r--r-- 1 root root  3969 Apr 17 04:55 depmod.d.5
-rw-r--r-- 1 root root  9306 Apr 17  2012 fonts-conf.5.gz
-rw-r--r-- 1 root root  1599 Apr 17  2012 initramfs.conf.5.gz
-rw-r--r-- 1 root root  8059 Apr 17 04:55 modprobe.d.5
-rw-r--r-- 1 root root  2494 Apr 17 04:55 modules.dep.5
-rw-r--r-- 1 root root    18 Apr 17 04:55 modules.dep.bin.5
-rw-r--r-- 1 root root   585 Apr 17  2012 update-initramfs.conf.5.gz
$ ls /usr/share/man/man8/ -l | grep &quot;Apr 17&quot;
-rw-r--r-- 1 root root  6398 Apr 17 04:55 depmod.8
-rw-r--r-- 1 root root  5170 Apr 17  2012 initramfs-tools.8.gz
-rw-r--r-- 1 root root  2151 Apr 17 04:55 insmod.8
-rw-r--r-- 1 root root   526 Apr 17  2012 lsinitramfs.8.gz
-rw-r--r-- 1 root root  1839 Apr 17 04:55 lsmod.8
-rw-r--r-- 1 root root  1570 Apr 17  2012 mkinitramfs.8.gz
-rw-r--r-- 1 root root  4009 Apr 17 04:55 modinfo.8
-rw-r--r-- 1 root root 10618 Apr 17 04:55 modprobe.8
-rw-r--r-- 1 root root  3058 Apr 17 04:55 rmmod.8
-rw-r--r-- 1 root root  1016 Apr 17  2012 update-initramfs.8.gz</code></pre>
<p>以上所有文件，均为 man 手册所准备的，通过 make install 将安装到系统路径 /usr/share/man/man8 下。</p>
<h3 id="功能简介">功能简介</h3>
<ul>
<li>libkmod.so
<ul>
<li>kmod 库的共享库文件，用于动态链接。</li>
</ul></li>
<li>libkmod.la
<ul>
<li>用 libtool 工具生成的库文件，其实就是一个文本文件，记录同名共享库的相关信息</li>
<li>libtool 工具的作用，是在编译大型软件的过程中解决了库的依赖问题。</li>
<li>特别是在交叉编译的条件下，解决动态链接器如何去寻找共享库的问题。</li>
</ul></li>
<li>kmod
<ul>
<li>一个管理内核模块的工具，提供列表list，加载load，卸载unload等功能。</li>
<li>目前的版本似乎只支持 help, list, static_nodes 三条命令</li>
<li>help 列出帮助信息</li>
<li>list 列出当前加载模块</li>
<li>static-nodes 输出当前内核加载的 static-node 信息，包括设备节点文件名，类型，主设备号和次设备号。</li>
</ul></li>
<li>libkmod.h
<ul>
<li>使用 libkmod 库所需要包含的头文件，详细接口定义见下节--项目代码分析。</li>
</ul></li>
<li>libkmod.pc
<ul>
<li>文本文件，包含了使用 libkmod 库所需要了解的一些信息，例如 安装目录，头文件所在目录，库名称，描述等。</li>
</ul></li>
<li>man5 &amp; man8
<ul>
<li>提供通过类似 man 8 insmod 命令来查看帮助的源文件 inssmod.8</li>
<li>提供通过类似 man 5 depmod.d 命令来查看帮助的源文件 depmod.d.5</li>
</ul></li>
</ul>
<h2 id="项目代码分析">3. 项目代码分析</h2>
<h3 id="源码目录结构">源码目录结构</h3>
<ul>
<li>tools
<ul>
<li>insmod.c</li>
<li>rmmod.c</li>
<li>lsmod.c</li>
<li>depmod.c</li>
<li>modinfo.c</li>
<li>modprobe.c</li>
<li>kmod.c</li>
<li>kmod.h</li>
<li>log.c</li>
<li>log.h</li>
<li>static-nodes.c</li>
</ul></li>
<li>libkmod
<ul>
<li>COPYING</li>
<li>docs</li>
<li>libkmod-array.c</li>
<li>libkmod-array.h</li>
<li>libkmod.c</li>
<li>libkmod-config.c</li>
<li>libkmod-elf.c</li>
<li>libkmod-file.c</li>
<li>libkmod.h</li>
<li>libkmod-hash.c</li>
<li>libkmod-hash.h</li>
<li>libkmod-index.c</li>
<li>libkmod-index.h</li>
<li>libkmod-list.c</li>
<li>libkmod-module.c</li>
<li>libkmod.pc.in</li>
<li>libkmod-private.h</li>
<li>libkmod-signature.c</li>
<li>libkmod.sym</li>
<li>libkmod-util.c</li>
<li>libkmod-util.h</li>
<li>macro.h</li>
<li>missing.h</li>
<li>README</li>
</ul></li>
<li>testsuite
<ul>
<li>COPYING</li>
<li>delete_module.c</li>
<li>init_module.c</li>
<li>mkdir.c</li>
<li>mkdir.h</li>
<li>path.c</li>
<li>README</li>
<li>rootfs-pristine</li>
<li>stripped-module.h</li>
<li>test-alias.c</li>
<li>test-blacklist.c</li>
<li>test-dependencies.c</li>
<li>test-depmod.c</li>
<li>test-init.c</li>
<li>test-loaded.c</li>
<li>test-modinfo.c</li>
<li>test-modprobe.c</li>
<li>test-new-module.c</li>
<li>testsuite.c</li>
<li>testsuite.h</li>
<li>test-testsuite.c</li>
<li>uname.c</li>
</ul></li>
<li>m4
<ul>
<li>attributes.m4</li>
</ul></li>
<li>man
<ul>
<li>depmod.d.xml</li>
<li>depmod.xml</li>
<li>insmod.xml</li>
<li>lsmod.xml</li>
<li>Makefile.am</li>
<li>modinfo.xml</li>
<li>modprobe.d.xml</li>
<li>modprobe.xml</li>
<li>modules.dep.xml</li>
<li>rmmod.xml</li>
</ul></li>
</ul>
<h3 id="头文件分析">头文件分析</h3>
<pre><code>$ cat /usr/include/libkmod.h 

/*
 * libkmod - interface to kernel module operations
 *
 * Copyright (C) 2011-2013  ProFUSION embedded systems
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */

#pragma once
#ifndef _LIBKMOD_H_
#define _LIBKMOD_H_

#include &lt;fcntl.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;inttypes.h&gt;

#ifdef __cplusplus
extern &quot;C&quot; {
#endif

/*
 * kmod_ctx
 *
 * library user context - reads the config and system
 * environment, user variables, allows custom logging
 */
struct kmod_ctx;
struct kmod_ctx *kmod_new(const char *dirname, const char * const *config_paths);
struct kmod_ctx *kmod_ref(struct kmod_ctx *ctx);
struct kmod_ctx *kmod_unref(struct kmod_ctx *ctx);
void kmod_set_log_fn(struct kmod_ctx *ctx,
            void (*log_fn)(void *log_data,
                    int priority, const char *file, int line,
                    const char *fn, const char *format,
                    va_list args),
            const void *data);
int kmod_get_log_priority(const struct kmod_ctx *ctx);
void kmod_set_log_priority(struct kmod_ctx *ctx, int priority);
void *kmod_get_userdata(const struct kmod_ctx *ctx);
void kmod_set_userdata(struct kmod_ctx *ctx, const void *userdata);


/*
 * Management of libkmod&#39;s resources
 */
int kmod_load_resources(struct kmod_ctx *ctx);
void kmod_unload_resources(struct kmod_ctx *ctx);

enum kmod_resources {
    KMOD_RESOURCES_OK = 0,
    KMOD_RESOURCES_MUST_RELOAD = 1,
    KMOD_RESOURCES_MUST_RECREATE = 2,
};
int kmod_validate_resources(struct kmod_ctx *ctx);

enum kmod_index {
    KMOD_INDEX_MODULES_DEP = 0,
    KMOD_INDEX_MODULES_ALIAS,
    KMOD_INDEX_MODULES_SYMBOL,
    KMOD_INDEX_MODULES_BUILTIN,
    /* Padding to make sure enum is not mapped to char */
    _KMOD_INDEX_PAD = (1 &lt;&lt; 31),
};
int kmod_dump_index(struct kmod_ctx *ctx, enum kmod_index type, int fd);

/*
 * kmod_list
 *
 * access to kmod generated lists
 */
struct kmod_list;
struct kmod_list *kmod_list_next(const struct kmod_list *list,
                        const struct kmod_list *curr);
struct kmod_list *kmod_list_prev(const struct kmod_list *list,
                        const struct kmod_list *curr);
struct kmod_list *kmod_list_last(const struct kmod_list *list);

#define kmod_list_foreach(list_entry, first_entry) \
    for (list_entry = first_entry; \
        list_entry != NULL; \
        list_entry = kmod_list_next(first_entry, list_entry))

#define kmod_list_foreach_reverse(list_entry, first_entry) \
    for (list_entry = kmod_list_last(first_entry); \
        list_entry != NULL; \
        list_entry = kmod_list_prev(first_entry, list_entry))

/*
 * kmod_config_iter
 *
 * access to configuration lists - it allows to get each configuration&#39;s
 * key/value stored by kmod
 */
struct kmod_config_iter;
struct kmod_config_iter *kmod_config_get_blacklists(const struct kmod_ctx *ctx);
struct kmod_config_iter *kmod_config_get_install_commands(const struct kmod_ctx *ctx);
struct kmod_config_iter *kmod_config_get_remove_commands(const struct kmod_ctx *ctx);
struct kmod_config_iter *kmod_config_get_aliases(const struct kmod_ctx *ctx);
struct kmod_config_iter *kmod_config_get_options(const struct kmod_ctx *ctx);
struct kmod_config_iter *kmod_config_get_softdeps(const struct kmod_ctx *ctx);
const char *kmod_config_iter_get_key(const struct kmod_config_iter *iter);
const char *kmod_config_iter_get_value(const struct kmod_config_iter *iter);
bool kmod_config_iter_next(struct kmod_config_iter *iter);
void kmod_config_iter_free_iter(struct kmod_config_iter *iter);

/*
 * kmod_module
 *
 * Operate on kernel modules
 */
struct kmod_module;
int kmod_module_new_from_name(struct kmod_ctx *ctx, const char *name,
                        struct kmod_module **mod);
int kmod_module_new_from_path(struct kmod_ctx *ctx, const char *path,
                        struct kmod_module **mod);
int kmod_module_new_from_lookup(struct kmod_ctx *ctx, const char *given_alias,
                        struct kmod_list **list);
int kmod_module_new_from_loaded(struct kmod_ctx *ctx,
                        struct kmod_list **list);

struct kmod_module *kmod_module_ref(struct kmod_module *mod);
struct kmod_module *kmod_module_unref(struct kmod_module *mod);
int kmod_module_unref_list(struct kmod_list *list);
struct kmod_module *kmod_module_get_module(const struct kmod_list *entry);


/* Removal flags */
enum kmod_remove {
    KMOD_REMOVE_FORCE = O_TRUNC,
    KMOD_REMOVE_NOWAIT = O_NONBLOCK,
};

/* Insertion flags */
enum kmod_insert {
    KMOD_INSERT_FORCE_VERMAGIC = 0x1,
    KMOD_INSERT_FORCE_MODVERSION = 0x2,
};

/* Flags to kmod_module_probe_insert_module() */
enum kmod_probe {
    KMOD_PROBE_FORCE_VERMAGIC =     0x00001,
    KMOD_PROBE_FORCE_MODVERSION =       0x00002,
    KMOD_PROBE_IGNORE_COMMAND =     0x00004,
    KMOD_PROBE_IGNORE_LOADED =      0x00008,
    KMOD_PROBE_DRY_RUN =            0x00010,
    KMOD_PROBE_FAIL_ON_LOADED =     0x00020,

    /* codes below can be used in return value, too */
    KMOD_PROBE_APPLY_BLACKLIST_ALL =    0x10000,
    KMOD_PROBE_APPLY_BLACKLIST =        0x20000,
    KMOD_PROBE_APPLY_BLACKLIST_ALIAS_ONLY = 0x40000,
};

/* Flags to kmod_module_apply_filter() */
enum kmod_filter {
    KMOD_FILTER_BLACKLIST = 0x00001,
    KMOD_FILTER_BUILTIN = 0x00002,
};

int kmod_module_remove_module(struct kmod_module *mod, unsigned int flags);
int kmod_module_insert_module(struct kmod_module *mod, unsigned int flags,
                            const char *options);
int kmod_module_probe_insert_module(struct kmod_module *mod,
            unsigned int flags, const char *extra_options,
            int (*run_install)(struct kmod_module *m,
                        const char *cmdline, void *data),
            const void *data,
            void (*print_action)(struct kmod_module *m, bool install,
                        const char *options));


const char *kmod_module_get_name(const struct kmod_module *mod);
const char *kmod_module_get_path(const struct kmod_module *mod);
const char *kmod_module_get_options(const struct kmod_module *mod);
const char *kmod_module_get_install_commands(const struct kmod_module *mod);
const char *kmod_module_get_remove_commands(const struct kmod_module *mod);
struct kmod_list *kmod_module_get_dependencies(const struct kmod_module *mod);
int kmod_module_get_softdeps(const struct kmod_module *mod,
                struct kmod_list **pre, struct kmod_list **post);
int kmod_module_get_filtered_blacklist(const struct kmod_ctx *ctx,
                    const struct kmod_list *input,
                    struct kmod_list **output) __attribute__ ((deprecated));
int kmod_module_apply_filter(const struct kmod_ctx *ctx,
                    enum kmod_filter filter_type,
                    const struct kmod_list *input,
                    struct kmod_list **output);



/*
 * Information regarding &quot;live information&quot; from module&#39;s state, as returned
 * by kernel
 */

enum kmod_module_initstate {
    KMOD_MODULE_BUILTIN = 0,
    KMOD_MODULE_LIVE,
    KMOD_MODULE_COMING,
    KMOD_MODULE_GOING,
    /* Padding to make sure enum is not mapped to char */
    _KMOD_MODULE_PAD = (1 &lt;&lt; 31),
};
const char *kmod_module_initstate_str(enum kmod_module_initstate state);
int kmod_module_get_initstate(const struct kmod_module *mod);
int kmod_module_get_refcnt(const struct kmod_module *mod);
struct kmod_list *kmod_module_get_holders(const struct kmod_module *mod);
struct kmod_list *kmod_module_get_sections(const struct kmod_module *mod);
const char *kmod_module_section_get_name(const struct kmod_list *entry);
unsigned long kmod_module_section_get_address(const struct kmod_list *entry);
void kmod_module_section_free_list(struct kmod_list *list);
long kmod_module_get_size(const struct kmod_module *mod);



/*
 * Information retrieved from ELF headers and sections
 */

int kmod_module_get_info(const struct kmod_module *mod, struct kmod_list **list);
const char *kmod_module_info_get_key(const struct kmod_list *entry);
const char *kmod_module_info_get_value(const struct kmod_list *entry);
void kmod_module_info_free_list(struct kmod_list *list);

int kmod_module_get_versions(const struct kmod_module *mod, struct kmod_list **list);
const char *kmod_module_version_get_symbol(const struct kmod_list *entry);
uint64_t kmod_module_version_get_crc(const struct kmod_list *entry);
void kmod_module_versions_free_list(struct kmod_list *list);

int kmod_module_get_symbols(const struct kmod_module *mod, struct kmod_list **list);
const char *kmod_module_symbol_get_symbol(const struct kmod_list *entry);
uint64_t kmod_module_symbol_get_crc(const struct kmod_list *entry);
void kmod_module_symbols_free_list(struct kmod_list *list);

enum kmod_symbol_bind {
    KMOD_SYMBOL_NONE = &#39;\0&#39;,
    KMOD_SYMBOL_LOCAL = &#39;L&#39;,
    KMOD_SYMBOL_GLOBAL = &#39;G&#39;,
    KMOD_SYMBOL_WEAK = &#39;W&#39;,
    KMOD_SYMBOL_UNDEF = &#39;U&#39;
};

int kmod_module_get_dependency_symbols(const struct kmod_module *mod, struct kmod_list **list);
const char *kmod_module_dependency_symbol_get_symbol(const struct kmod_list *entry);
int kmod_module_dependency_symbol_get_bind(const struct kmod_list *entry);
uint64_t kmod_module_dependency_symbol_get_crc(const struct kmod_list *entry);
void kmod_module_dependency_symbols_free_list(struct kmod_list *list);

#ifdef __cplusplus
} /* extern &quot;C&quot; */
#endif
#endif
$ </code></pre>
<ul>
<li>头文件是 libkmod 项目所提供的用于包含的函数调用接口，上层编程者一般都需要 include 这个文件。</li>
<li>以 insmod 命令实现为例，以下函数接口将会用于这个命令实现过程中，典型的调用用法如下：
<ul>
<li>kmod_new()</li>
<li>kmod_module_new_from_path()</li>
<li>kmod_module_insert_module()</li>
<li>kmod_module_unref()</li>
</ul></li>
</ul>
<h3 id="数据结构设计">数据结构设计</h3>
<ul>
<li>struct kmod_ctx
<ul>
<li>该结构体出现在 libkmod/libkmod.c 文件中</li>
<li>用于读取配置和系统环境参数，用户参数等</li>
</ul></li>
</ul>
<p>结构体定义</p>
<pre><code>/**
 * kmod_ctx:
 *
 * Opaque object representing the library context.
 */
struct kmod_ctx {
    int refcount;
    int log_priority;
    void (*log_fn)(void *data,
                    int priority, const char *file, int line,
                    const char *fn, const char *format, va_list args);
    void *log_data;
    const void *userdata;
    char *dirname;
    struct kmod_config *config;
    struct hash *modules_by_name;
    struct index_mm *indexes[_KMOD_INDEX_MODULES_SIZE];
    unsigned long long indexes_stamp[_KMOD_INDEX_MODULES_SIZE];
};</code></pre>
<ul>
<li>struct kmod_list
<ul>
<li>该结构体出现在 libkmod/libkmod-private.h 文件中</li>
<li>用于访问 kmod 产生的模块节点链表</li>
</ul></li>
</ul>
<p>结构体定义</p>
<pre><code>struct list_node {
    struct list_node *next, *prev;
};

struct kmod_list {
    struct list_node node;
    void *data;
};</code></pre>
<ul>
<li>struct kmod_config_iter
<ul>
<li>该结构体出现在 libkmod/libkmod-config.c 文件中</li>
</ul></li>
</ul>
<p>结构体定义</p>
<pre><code>struct kmod_config_iter {
    enum config_type type;
    bool intermediate;
    const struct kmod_list *list;
    const struct kmod_list *curr;
    void *data;
    const char *(*get_key)(const struct kmod_list *l); 
    const char *(*get_value)(const struct kmod_list *l); 
};</code></pre>
<ul>
<li>struct kmod_module
<ul>
<li>该结构体出现在 libkmod/libkmod-module.c 文件中</li>
</ul></li>
</ul>
<p>结构体定义</p>
<pre><code>/**
 * SECTION:libkmod-module
 * @short_description: operate on kernel modules
 */

/**
 * kmod_module:
 *
 * Opaque object representing a module.
 */
struct kmod_module {
    struct kmod_ctx *ctx;
    char *hashkey;
    char *name;
    char *path;
    struct kmod_list *dep;
    char *options;
    const char *install_commands;   /* owned by kmod_config */
    const char *remove_commands;    /* owned by kmod_config */
    char *alias; /* only set if this module was created from an alias */
    struct kmod_file *file;
    int n_dep;
    int refcount;
    struct {
        bool dep : 1;
        bool options : 1;
        bool install_commands : 1;
        bool remove_commands : 1;
    } init;

    /*
     * private field used by kmod_module_get_probe_list() to detect
     * dependency loops
     */
    bool visited : 1;

    /*
     * set by kmod_module_get_probe_list: indicates for probe_insert()
     * whether the module&#39;s command and softdep should be ignored
     */
    bool ignorecmd : 1;

    /*
     * if module was created by searching the modules.builtin file, this
     * is set. There&#39;s nothing much useful one can do with such a
     * &quot;module&quot;, except knowing it&#39;s builtin.
     */
    bool builtin : 1;
};</code></pre>
<h3 id="重要接口实现">重要接口实现</h3>
<ul>
<li>kmod_module_insert_module() in libkmod/libkmod-module.c
<ul>
<li>kmod_module_get_path()</li>
<li>file = kmod_file_open()</li>
<li>kmod_file_get_direct()</li>
<li>size = kmod_file_get_size(file)</li>
<li>mem = kmod_file_get_contents(file)</li>
<li>kmod_elf_new()</li>
<li>kmod_elf_strip_section()</li>
<li>kmod_elf_get_memory()</li>
<li>init_module(mem, size, args)</li>
<li>kmod_elf_unref()</li>
<li>kmod_file_unref()</li>
</ul></li>
<li>对比 module-init-tools 的实现，可以发现代码的层次逻辑复杂不少
<ul>
<li>realloc()</li>
<li>grab_file()
<ul>
<li>open()</li>
<li>malloc()</li>
<li>read()</li>
<li>close()</li>
</ul></li>
<li>init_module(file, len, options)</li>
<li>free()</li>
</ul></li>
<li>kmod_module_remove_module in libkmod/libkmod-module.c
<ul>
<li>delete_module()</li>
</ul></li>
</ul>
<h1 id="kmod-11-详细分析报告">kmod-11 详细分析报告</h1>
<h2 id="架构分析">1. 架构分析</h2>
<p>kmod-11 项目的整个技术架构分为3层。最上层是tools目录下的6个命令，中间是libkmod库所提供的各种编程接口，最下层是testsuite所包含的系统调用抽象层，便于在用户空间进行接口测试。</p>
<p>kmod-11 项目系统层次结构如图</p>
<div class="figure">
<img src="./figures/0-overview.jpg" alt="kmod-11 项目系统结构层次图" /><p class="caption">kmod-11 项目系统结构层次图</p>
</div>
<p>下面按照这样的三层架构，按照应用层，库接口层，抽象层的顺序，依次分析。</p>
<h3 id="应用层">应用层</h3>
<p>应用层实现了6个常用的用户命令，分别是 insmod, rmmod, lsmod, modinfo, depmod, modprobe.</p>
<div class="figure">
<img src="./figures/1-app.jpg" alt="kmod-11 项目应用层结构图" /><p class="caption">kmod-11 项目应用层结构图</p>
</div>
<h4 id="insmod-命令">insmod 命令</h4>
<p>该命令的功能是: 向Linux内核中插入一个模块</p>
<pre><code>$ ./kmod-11/tools/insmod -h

Usage:
    insmod [options] filename [args]
Options:
    -V, --version     show version
    -h, --help        show this help</code></pre>
<h4 id="rmmod-命令">rmmod 命令</h4>
<p>该命令的功能是: 删除内核中的模块</p>
<pre><code>$ ./kmod-11/tools/rmmod -h
Usage:
    rmmod [options] modulename ...
Options:
    -f, --force       forces a module unload and may crash your
                  machine. This requires Forced Module Removal
                  option in your kernel. DANGEROUS
    -s, --syslog      print to syslog, not stderr
    -v, --verbose     enables more messages
    -V, --version     show version
    -h, --help        show this help</code></pre>
<h4 id="lsmod-命令">lsmod 命令</h4>
<p>该命令的功能是: 列出内核已载入模块的状态</p>
<pre><code>$ ./kmod-11/tools/lsmod -h
Usage: ./kmod-11/tools/lsmod</code></pre>
<h4 id="modinfo-命令">modinfo 命令</h4>
<p>该命令的功能是: 显示内核模块的信息</p>
<pre><code>$ ./kmod-11/tools/modinfo -h
Usage:
    modinfo [options] filename [args]
Options:
    -a, --author                Print only &#39;author&#39;
    -d, --description           Print only &#39;description&#39;
    -l, --license               Print only &#39;license&#39;
    -p, --parameters            Print only &#39;parm&#39;
    -n, --filename              Print only &#39;filename&#39;
    -0, --null                  Use \0 instead of \n
    -F, --field=FIELD           Print only provided FIELD
    -k, --set-version=VERSION   Use VERSION instead of `uname -r`
    -b, --basedir=DIR           Use DIR as filesystem root for /lib/modules
    -V, --version               Show version
    -h, --help                  Show this help
$ </code></pre>
<h4 id="depmod-命令">depmod 命令</h4>
<p>该命令的功能是: 分析可加载模块的依赖性，生成modules.dep文件和映射文件。</p>
<pre><code>$ ./kmod-11/tools/depmod -h
Usage:
    depmod -[aA] [options] [forced_version]

If no arguments (except options) are given, &quot;depmod -a&quot; is assumed

depmod will output a dependency list suitable for the modprobe utility.

Options:
    -a, --all            Probe all modules
    -A, --quick          Only does the work if there&#39;s a new module
    -e, --errsyms        Report not supplied symbols
    -n, --show           Write the dependency file on stdout only
    -P, --symbol-prefix  Architecture symbol prefix
    -C, --config=PATH    Read configuration from PATH
    -v, --verbose        Enable verbose mode
    -w, --warn           Warn on duplicates
    -V, --version        show version
    -h, --help           show this help

The following options are useful for people managing distributions:
    -b, --basedir=DIR    Use an image of a module tree.
    -F, --filesyms=FILE  Use the file instead of the
                     current kernel symbols.
    -E, --symvers=FILE   Use Module.symvers file to check
                     symbol versions.
$ </code></pre>
<h4 id="modprobe-命令">modprobe 命令</h4>
<p>该命令的功能是: Linux内核添加或者删除模块</p>
<pre><code>$ ./kmod-11/tools/modprobe -h
Usage:
    modprobe [options] [-i] [-b] modulename
    modprobe [options] -a [-i] [-b] modulename [modulename...]
    modprobe [options] -r [-i] modulename
    modprobe [options] -r -a [-i] modulename [modulename...]
    modprobe [options] -c
    modprobe [options] --dump-modversions filename
Management Options:
    -a, --all                   Consider every non-argument to
                            be a module name to be inserted
                            or removed (-r)
    -r, --remove                Remove modules instead of inserting
        --remove-dependencies   Also remove modules depending on it
    -R, --resolve-alias         Only lookup and print alias and exit
        --first-time            Fail if module already inserted or removed
    -i, --ignore-install        Ignore install commands
    -i, --ignore-remove         Ignore remove commands
    -b, --use-blacklist         Apply blacklist to resolved alias.
    -f, --force                 Force module insertion or removal.
                            implies --force-modversions and
                            --force-vermagic
        --force-modversion      Ignore module&#39;s version
        --force-vermagic        Ignore module&#39;s version magic

Query Options:
    -D, --show-depends          Only print module dependencies and exit
    -c, --showconfig            Print out known configuration and exit
    -c, --show-config           Same as --showconfig
        --show-modversions      Dump module symbol version and exit
        --dump-modversions      Same as --show-modversions

General Options:
    -n, --dry-run               Do not execute operations, just print out
    -n, --show                  Same as --dry-run
    -C, --config=FILE           Use FILE instead of default search paths
    -d, --dirname=DIR           Use DIR as filesystem root for /lib/modules
    -S, --set-version=VERSION   Use VERSION instead of `uname -r`
    -s, --syslog                print to syslog, not stderr
    -q, --quiet                 disable messages
    -v, --verbose               enables more messages
    -V, --version               show version
    -h, --help                  show this help
$ </code></pre>
<h3 id="库接口层">库接口层</h3>
<p>库接口层包含了 libkmod 目录下的形如 libkmod-xxx.c 的模块文件，其中涉及用到的编程接口将近100个，形如 kmod_xxx_xxx_xxx 的接口函数。</p>
<p>按照这些接口函数的归属模块划分，我们经过代码分析，可以将它们分为6个重要的核心子模块，分别是 kmod_ctx, kmod_module, kmod_config, kmod_list, kmod_elf, kmod_file。</p>
<div class="figure">
<img src="./figures/2-core.jpg" alt="kmod-11 项目库接口层核心子模块结构图" /><p class="caption">kmod-11 项目库接口层核心子模块结构图</p>
</div>
<p>另外还有6个属于基础类的子模块，为以上6个核心子模块提供支持，分别是 hash, index_mm，elf，list，array，log。</p>
<div class="figure">
<img src="./figures/2-base.jpg" alt="kmod-11 项目库接口层基础子模块结构图" /><p class="caption">kmod-11 项目库接口层基础子模块结构图</p>
</div>
<p>以下在模块分析小节将分别对这12个模块进行详细说明。</p>
<h3 id="系统调用抽象层">系统调用抽象层</h3>
<p>系统调用抽象层的实现代码主要集中在 testsuite 目录下，其中最重要的2个实现包含 init_module 系统调用和 delete_module 系统调用的模拟实现。</p>
<div class="figure">
<img src="./figures/3-syscall.jpg" alt="kmod-11 项目系统调用抽象层结构图" /><p class="caption">kmod-11 项目系统调用抽象层结构图</p>
</div>
<h3 id="各层之间相互关系图">各层之间相互关系图</h3>
<p>以上的命令，库，核心子模块，基础子模块以及系统调用抽象层，之间的关系并不是明显分开的，而是互相之间有交错的关系。为了更清楚的说明整个系统各个层次之间的调用关系，我们以下图为例，做简要说明。</p>
<div class="figure">
<img src="./figures/sys.jpg" alt="kmod-11 项目系统各层结构关系图" /><p class="caption">kmod-11 项目系统各层结构关系图</p>
</div>
<p>其中命令层就是应用层，一般命令的实现都会首先使用 kmod_ctx 和 kmod_module 两个核心子模块的接口，其中 kmod_ctx 调用了 kmod_config 核心子模块和 hash, log, index_mm 基础子模块的接口功能，kmod_module 调用了 kmod_file, kmod_elf, kmod_list 这3个核心子模块的接口功能，以及简介调用了 elf, list 这2个基础子模块的接口功能，同时还使用了模拟层中有关系统调用模拟实现的接口。</p>
<p>因此在我们所列出的6个核心子模块中，kmod_ctx 和 kmod_module 这2个核心子模块占据着更为重要的作用，是整个 libkmod 库的核心中的核心。在下面的分析中，我们还会详细论述它们的功能。</p>
<h2 id="模块分析">2. 模块分析</h2>
<h3 id="kmod_ctx">kmod_ctx</h3>
<h3 id="kmod_module">kmod_module</h3>
<h3 id="kmod_elf">kmod_elf</h3>
<h3 id="kmod_file">kmod_file</h3>
<h3 id="kmod_config">kmod_config</h3>
<h3 id="hash">hash</h3>
<h3 id="kmod_list">kmod_list</h3>
<h3 id="index_mm">index_mm</h3>
<h3 id="elf">elf</h3>
<h3 id="list">list</h3>
<h3 id="array">array</h3>
<h3 id="log">log</h3>
<h2 id="运行时调试图">3. 运行时调试图</h2>
<h3 id="insmod-命令运行时调试图">insmod 命令运行时调试图</h3>
<h4 id="编写测试用内核模块源码-hello.c">编写测试用内核模块源码 hello.c</h4>
<pre><code>$ cat hello.c 

#include &lt;linux/module.h&gt;
#include &lt;linux/kernel.h&gt;

MODULE_AUTHOR(&quot;AKAEDU&quot;);
MODULE_DESCRIPTION(&quot;module example &quot;);
MODULE_LICENSE(&quot;GPL&quot;);

int global = 100;

int __init 
akae_init (void)
{
    int local = 200;
    printk (&quot;Hello, akaedu\n&quot;);

    printk(&quot;.text = %p\n&quot;, akae_init);
    printk(&quot;.data = %p\n&quot;, &amp;global);
    printk(&quot;.stack = %p\n&quot;, &amp;local);
    return 0;
}

void __exit
akae_exit (void)
{
    int local = 300;
    printk (&quot;module exit\n&quot;);

    printk(&quot;.text = %p\n&quot;, akae_exit);
    printk(&quot;.data = %p\n&quot;, &amp;global);
    printk(&quot;.stack = %p\n&quot;, &amp;local);
    return ;
}

module_init(akae_init);
module_exit(akae_exit);
$ </code></pre>
<h4 id="编写测试用内核模块的-makefile-文件-makefile">编写测试用内核模块的 Makefile 文件 Makefile</h4>
<pre><code>$ cat Makefile 

obj-m := hello.o

KDIR := /usr/src/linux-headers-3.2.0-29-generic-pae/

all:
    make -C $(KDIR) SUBDIRS=$(PWD)  modules

clean:
    rm -rf *.o *.ko *.mod.* *.cmd 
    rm -rf .*

$ </code></pre>
<h4 id="编译内核模块-hello.ko">编译内核模块 hello.ko</h4>
<pre><code>$ cd hello-module/ 
$ make
make -C /usr/src/linux-headers-3.2.0-29-generic-pae/    SUBDIRS=/home/akaedu/Github/comment-subs/hello-module   modules
make[1]: Entering directory `/usr/src/linux-headers-3.2.0-29-generic-pae&#39;
  CC [M]  /home/akaedu/Github/comment-subs/hello-module/hello.o
  Building modules, stage 2.
  MODPOST 1 modules
  CC      /home/akaedu/Github/comment-subs/hello-module/hello.mod.o
  LD [M]  /home/akaedu/Github/comment-subs/hello-module/hello.ko
make[1]: Leaving directory `/usr/src/linux-headers-3.2.0-29-generic-pae&#39;
$ </code></pre>
<h4 id="编译生成测试用工具-insmod">编译生成测试用工具 insmod</h4>
<pre><code>$ cd kmod-11/ 
$ make
make --no-print-directory all-recursive
Making all in .
  CC       libkmod/libkmod.lo
  CC       libkmod/libkmod-list.lo
  CC       libkmod/libkmod-config.lo
  CC       libkmod/libkmod-index.lo
  CC       libkmod/libkmod-module.lo
  CC       libkmod/libkmod-file.lo
  CC       libkmod/libkmod-elf.lo
  CC       libkmod/libkmod-hash.lo
  CC       libkmod/libkmod-array.lo
  CC       libkmod/libkmod-util.lo
  CCLD     libkmod/libkmod-util.la
  CCLD     libkmod/libkmod.la
  CCLD     libkmod/libkmod-private.la
  CC       tools/kmod.o
  CC       tools/lsmod.o
  CC       tools/rmmod.o
  CC       tools/insmod.o
  CC       tools/modinfo.o
  CC       tools/modprobe.o
  CC       tools/depmod.o
  CC       tools/log.o
  CCLD     tools/kmod
  CCLD     tools/kmod-nolib
  GEN      libkmod/libkmod.pc
Making all in libkmod/docs
make[2]: Nothing to be done for `all&#39;.
Making all in man
  GEN      depmod.d.5
  GEN      modprobe.d.5
  GEN      modules.dep.5
  GEN      depmod.8
  GEN      insmod.8
  GEN      lsmod.8
  GEN      rmmod.8
  GEN      modprobe.8
  GEN      modinfo.8
$ </code></pre>
<h4 id="使用测试用工具-insmod-插入内核模块">使用测试用工具 insmod 插入内核模块</h4>
<pre><code>$ sudo ./kmod-11/tools/insmod hello-module/hello.ko </code></pre>
<h4 id="查看插入内核模块后的打印结果">查看插入内核模块后的打印结果</h4>
<pre><code>$ lsmod | grep hello
hello                  12415  0 
$ dmesg | tail
[350775.859640] usb 2-2.1: USB disconnect, device number 14
[350777.611134] Bluetooth: hci0 urb c7304180 submission failed
[350778.217886] usb 2-2.1: new full-speed USB device number 15 using uhci_hcd
[352048.604051] usb 2-2.1: USB disconnect, device number 15
[352048.630829] Bluetooth: hci0 urb dd3d3000 submission failed
[352049.254135] usb 2-2.1: new full-speed USB device number 16 using uhci_hcd
[352111.505217] Hello, akaedu
[352111.505223] .text = e0844000
[352111.505225] .data = e0c03000
[352111.505227] .stack = df6e3f54
$ </code></pre>
<h4 id="重复插入同样的内核模块系统会报错">重复插入同样的内核模块系统会报错</h4>
<pre><code>$ sudo ./kmod-11/tools/insmod hello-module/hello.ko 
insmod: ERROR: could not insert module hello-module/hello.ko: File exists
$ lsmod | grep hello
hello                  12415  0 </code></pre>
<h3 id="rmmod-命令运行时调试图">rmmod 命令运行时调试图</h3>
<h4 id="使用测试用工具-rmmod-卸载内核模块">使用测试用工具 rmmod 卸载内核模块</h4>
<pre><code>$ sudo ./kmod-11/tools/rmmod hello-module/hello.ko
$ （rmmod 命令的执行，运行在 hello 的后面加上 .ko 的后缀，这个和以前的命令有所不同）</code></pre>
<h4 id="查看卸载内核模块后的打印结果">查看卸载内核模块后的打印结果</h4>
<pre><code>$ lsmod | grep hello
$ （可以看到上面命令的执行结果没有任何输出信息）
$ dmesg | tail
[352048.630829] Bluetooth: hci0 urb dd3d3000 submission failed
[352049.254135] usb 2-2.1: new full-speed USB device number 16 using uhci_hcd
[352111.505217] Hello, akaedu
[352111.505223] .text = e0844000
[352111.505225] .data = e0c03000
[352111.505227] .stack = df6e3f54
[352365.795618] module exit
[352365.795624] .text = e0c01000
[352365.795626] .data = e0c03000
[352365.795628] .stack = dd197f40
$ </code></pre>
<h2 id="运行流程分析">4. 运行流程分析</h2>
<h3 id="insmod-命令实现流程">insmod 命令实现流程</h3>
<p>insmod 命令和其他所有命令一样，都是采用了一个统一的调用方法。实现了一个 struct kmod_cmd 的数据结构，这个数据结构定义在 kmod-11/tools/kmod.h 文件中。</p>
<pre><code>struct kmod_cmd {
    const char *name;
    int (*cmd)(int argc, char *argv[]);
    const char *help;
};</code></pre>
<p>在 kmod-11/tools/insmod.c 文件中，用这个结构体定义了</p>
<pre><code>160 
161 const struct kmod_cmd kmod_cmd_compat_insmod = {
162         .name = &quot;insmod&quot;,
163         .cmd = do_insmod,
164         .help = &quot;compat insmod command&quot;,
165 };</code></pre>
<p>在 kmod-11/tools/kmod.c 文件中，实现了一个通用的 main 方法。</p>
<pre><code>166 int main(int argc, char *argv[])
167 {
168         int err;
169 
170         if (strcmp(program_invocation_short_name, &quot;kmod&quot;) == 0)
171                 err = handle_kmod_commands(argc, argv);
172         else
173                 err = handle_kmod_compat_commands(argc, argv);
174 
175         return err;
176 }</code></pre>
<p>在这个main函数中，调用了 handle_kmod_compat_commands 函数。</p>
<pre><code>149 
150 static int handle_kmod_compat_commands(int argc, char *argv[])
151 {
152         const char *cmd;
153         size_t i;
154 
155         cmd = basename(argv[0]);
156 
157         for (i = 0; i &lt; ARRAY_SIZE(kmod_compat_cmds); i++) {
158                 if (strcmp(kmod_compat_cmds[i]-&gt;name, cmd) == 0)
159                         return kmod_compat_cmds[i]-&gt;cmd(argc, argv);
160         }
161 
162         return -ENOENT;
163 }
164 </code></pre>
<p>handle_kmod_compat_commands 这个函数很简单，就是一个for循环遍历整个 kmod_compat_cmds，找出每一个 kmod_compat_cmds[i] 来进行名称 name 匹配，如果匹配上了，就调用相应的函数指针 cmd 来执行该操作。</p>
<p>kmod_compat_cmds 这个数组目前有6个元素，分别就是在 insmod.c rmmod.c lsmod.c modinfo.c depmod.c modprobe.c 这6个文件中定义的全局结构体。</p>
<pre><code> 44
 45 static const struct kmod_cmd *kmod_compat_cmds[] = {
 46         &amp;kmod_cmd_compat_lsmod,
 47         &amp;kmod_cmd_compat_rmmod,
 48         &amp;kmod_cmd_compat_insmod,
 49         &amp;kmod_cmd_compat_modinfo,
 50         &amp;kmod_cmd_compat_modprobe,
 51         &amp;kmod_cmd_compat_depmod,
 52 };</code></pre>
<p>最后所有 tools 目录下的可执行文件，都是以软链接的方式，链接到唯一的一个可执行文件 kmod-nolib 上。</p>
<pre><code>$ ls kmod-11/tools/ -l | grep ^l
lrwxrwxrwx 1 akaedu akaedu     10 Jun  9 19:23 depmod -&gt; kmod-nolib
lrwxrwxrwx 1 akaedu akaedu     10 Jun  9 19:23 insmod -&gt; kmod-nolib
lrwxrwxrwx 1 akaedu akaedu     10 Jun  9 19:23 lsmod -&gt; kmod-nolib
lrwxrwxrwx 1 akaedu akaedu     10 Jun  9 19:23 modinfo -&gt; kmod-nolib
lrwxrwxrwx 1 akaedu akaedu     10 Jun  9 19:23 modprobe -&gt; kmod-nolib
lrwxrwxrwx 1 akaedu akaedu     10 Jun  9 19:23 rmmod -&gt; kmod-nolib
$ </code></pre>
<p>我们可以用一张图来表示这些文件和数据结构之间的关系。</p>
<div class="figure">
<img src="./figures/cmd.jpg" alt="命令实现结构图" /><p class="caption">命令实现结构图</p>
</div>
<p><strong>do_insmod 核心代码分析</strong></p>
<p>分析到这里，我们就进入到了 insmod 命令实现最核心的部分 do_insmod() 函数，后面的其他几个命令也都是类似的方法，进入到 do_xxx() 中，之后的分析关于这部分不再赘述。下面我们来看看 do_insmod() 函数实现中最核心的部分代码摘要。</p>
<pre><code>do_insmod()
{
    opts = argv[x]; // name=value
    ctx = kmod_new(NULL, &amp;null_config);
    err = kmod_module_new_from_path(ctx, filename, &amp;mod);
    err = kmod_module_insert_module(mod, 0, opts);
    kmod_module_unref(mod);
    kmod_unref(ctx);
}</code></pre>
<p>注意这个小节中后面的绝大部分代码都不是原代码的引用，而是将其中最核心的函数调用和传入传出的参数整理到函数体内部，为便于查看函数调用关系而做了简化。</p>
<div class="figure">
<img src="./figures/insmod.jpg" alt="insmod 调用层次图" /><p class="caption">insmod 调用层次图</p>
</div>
<p>do_insmod() 的实现可以分为5个步骤</p>
<ul>
<li>创建模块的上下文 struct kmod_ctx ctx</li>
<li>通过 filename 和 ctx 获得模块 struct kmod_module mod</li>
<li>将 mod 插入到当前模块列表中, 完成真正的插入内核功能</li>
<li>释放 mod</li>
<li>释放 ctx</li>
</ul>
<p>涉及到两个模块的5个接口，两个模块是</p>
<ul>
<li>libkmod/libkmod.c
<ul>
<li>kmod_new()</li>
<li>kmod_unref()</li>
</ul></li>
<li>libkmod/libkmod-module.c
<ul>
<li>kmod_module_new_from_path()</li>
<li>kmod_module_insert_module()</li>
<li>kmod_module_unref()</li>
</ul></li>
</ul>
<h3 id="rmmod-命令实现流程">rmmod 命令实现流程</h3>
<p><strong>do_rmmod 核心代码分析</strong></p>
<p>下面我们来看看 do_rmmod() 函数实现中最核心的部分代码摘要。</p>
<pre><code>do_rmmod()
{
    log_open(use_syslog);
    ctx = kmod_new(NULL, &amp;null_config);
    log_setup_kmod_log(ctx, verbose);
    arg = argv[i];
    err = kmod_module_new_from_path(ctx, arg, &amp;mod);
    err = kmod_module_new_from_name(ctx, arg, &amp;mod);
    check_module_inuse(mod);
    err = kmod_module_remove_module(mod, flags);
    kmod_module_unref(mod);
    kmod_unref(ctx);
    log_close();
}</code></pre>
<div class="figure">
<img src="./figures/rmmod.jpg" alt="rmmod 调用层次图" /><p class="caption">rmmod 调用层次图</p>
</div>
<p>do_rmmod() 的实现可以分为5个步骤</p>
<ul>
<li>创建模块的上下文 struct kmod_ctx ctx</li>
<li>通过 filename 和 ctx 获得模块 struct kmod_module mod</li>
<li>将 mod 插入到当前模块列表中, 完成真正的插入内核功能</li>
<li>释放 mod</li>
<li>释放 ctx</li>
</ul>
<p>涉及到两个模块的5个接口，两个模块是</p>
<ul>
<li>libkmod/libkmod.c
<ul>
<li>kmod_new()</li>
<li>kmod_unref()</li>
</ul></li>
<li>libkmod/libkmod-module.c
<ul>
<li>kmod_module_new_from_path()</li>
<li>kmod_module_insert_module()</li>
<li>kmod_module_unref()</li>
</ul></li>
</ul>
<h3 id="lsmod-命令实现流程">lsmod 命令实现流程</h3>
<div class="figure">
<img src="./figures/insmod.jpg" alt="insmod 调用层次图" /><p class="caption">insmod 调用层次图</p>
</div>
<h3 id="modinfo-命令实现流程">modinfo 命令实现流程</h3>
<div class="figure">
<img src="./figures/insmod.jpg" alt="insmod 调用层次图" /><p class="caption">insmod 调用层次图</p>
</div>
<h3 id="depmod-命令实现流程">depmod 命令实现流程</h3>
<div class="figure">
<img src="./figures/depmod.jpg" alt="depmod 调用层次图" /><p class="caption">depmod 调用层次图</p>
</div>
<p><strong>do_depmod() 核心代码分析</strong></p>
<pre><code>do_depmod(int argc, char *argv[])
{
    out = stdout;       
    ctx = kmod_new(cfg.dirname, &amp;null_kmod_config);

    err = depmod_init(&amp;depmod, &amp;cfg, ctx);
    err = depmod_load_symvers(&amp;depmod, module_symvers);
    err = depmod_load_system_map(&amp;depmod, system_map);
    err = cfg_load(&amp;cfg, config_paths);
    err = depmod_modules_search(&amp;depmod);
    err = kmod_module_new_from_path(depmod.ctx, path, &amp;mod);
    err = depmod_module_add(&amp;depmod, mod);
    err = depmod_modules_build_array(&amp;depmod);
    depmod_modules_sort(&amp;depmod);
    err = depmod_load(&amp;depmod);

    err = depmod_output(&amp;depmod, out);
    depmod_shutdown(&amp;depmod);
    cfg_free(&amp;cfg);
    kmod_unref(ctx);
}</code></pre>
<p>下面根据这个核心代码，将在一层逻辑过程中调用到的函数，做一个简要的说明。 所有这些函数可以分为3类，分别形如 kmod_xxx，depmod_xxx, cfg_xxx 开头的。</p>
<p><strong>kmod_xxx</strong> 包含 kmod_new, kmod_module_new_from_path, kmod_unref 这3个在之前的代码分析中介绍过。</p>
<p><strong>depmod_xxx</strong> 这些函数都被声明为 static 的类型，说明仅仅只是为 depmod 命令的实现而服务的，不属于 libkmod 库要提供的接口。 * depmod 内部子模块上层接口 - depmod_init - depmod_load_symvers - depmod_load_system_map - depmod_modules_search - depmod_module_add - depmod_modules_build_array - depmod_modules_sort - depmod_shutdown</p>
<ul>
<li><p>围绕上面这些函数，还需要调用到如下接口</p>
<p>static int depmod_init(struct depmod *depmod, struct cfg *cfg, struct kmod_ctx *ctx) { array_init(&amp;depmod-&gt;modules, 128);</p>
<pre><code>depmod-&gt;modules_by_uncrelpath = hash_new(512, NULL);
depmod-&gt;modules_by_name = hash_new(512, NULL);
depmod-&gt;symbols = hash_new(2048, (void (*)(void *))symbol_free);

hash_free(depmod-&gt;modules_by_name);
hash_free(depmod-&gt;modules_by_uncrelpath);

return err;</code></pre>
<p>}</p>
<p>static int depmod_load_symvers(struct depmod *depmod, const char *filename) { fp = fopen(filename, &quot;r&quot;); while (fgets(line, sizeof(line), fp) != NULL) { ver = strtok(line, &quot; &quot;);</p>
<pre><code>depmod_symbol_add(depmod, sym, crc, NULL);
depmod_add_fake_syms(depmod);

fclose(fp);
return 0;</code></pre>
<p>}</p>
<p>static int depmod_load_system_map(struct depmod *depmod, const char *filename) { fp = fopen(filename, &quot;r&quot;); while (fgets(line, sizeof(line), fp) != NULL) { p = strchr(line, ' '); depmod_symbol_add(depmod, p + ksymstr_len, 0, NULL); depmod_add_fake_syms(depmod); fclose(fp); return 0; }</p>
<p>static int depmod_modules_search(struct depmod *depmod) { DIR *d = opendir(depmod-&gt;cfg-&gt;dirname); err = depmod_modules_search_dir(depmod, d, baselen, path); closedir(d); return err; }</p>
<p>static int depmod_module_add(struct depmod *depmod, struct kmod_module *kmod) { modname = kmod_module_get_name(kmod);</p>
<pre><code>mod = calloc(1, sizeof(struct mod) + modnamelen);

array_init(&amp;mod-&gt;deps, 4);

err = hash_add_unique(depmod-&gt;modules_by_name, mod-&gt;modname, mod);

return 0;</code></pre>
<p>}</p>
<p>static int depmod_modules_build_array(struct depmod *depmod) { hash_iter_init(depmod-&gt;modules_by_name, &amp;module_iter);</p>
<pre><code>while (hash_iter_next(&amp;module_iter, NULL, &amp;v)) {
        struct mod *mod = (struct mod *) v;
        mod-&gt;idx = depmod-&gt;modules.count;
        err = array_append(&amp;depmod-&gt;modules, mod);
        if (err &lt; 0)
                return err;
}
return 0;</code></pre>
<p>}</p>
<p>static void depmod_modules_sort(struct depmod *depmod) { snprintf(order_file, sizeof(order_file), &quot;%s/modules.order&quot;, depmod-&gt;cfg-&gt;dirname); fp = fopen(order_file, &quot;r&quot;);</p>
<pre><code>while (fgets(line, sizeof(line), fp) != NULL) {
    mod = hash_find(depmod-&gt;modules_by_uncrelpath, line);
}

array_sort(&amp;depmod-&gt;modules, mod_cmp);

for (idx = 0; idx &lt; depmod-&gt;modules.count; idx++) {
        struct mod *m = depmod-&gt;modules.array[idx];
        m-&gt;idx = idx;
}</code></pre>
<p>}</p>
<p>static void depmod_shutdown(struct depmod *depmod) { hash_free(depmod-&gt;symbols);</p>
<pre><code>hash_free(depmod-&gt;modules_by_uncrelpath);

hash_free(depmod-&gt;modules_by_name);

for (i = 0; i &lt; depmod-&gt;modules.count; i++)
        mod_free(depmod-&gt;modules.array[i]);

array_free_array(&amp;depmod-&gt;modules);

kmod_unref(depmod-&gt;ctx);</code></pre>
<p>}</p></li>
</ul>
<p><strong>cfg_xxx</strong></p>
<pre><code>static int cfg_load(struct cfg *cfg, const char * const *cfg_paths)
{
    for (i = 0; cfg_paths[i] != NULL; i++)
            cfg_files_list(&amp;files, &amp;n_files, cfg_paths[i]);

    for (i = 0; i &lt; n_files; i++) {
            struct cfg_file *f = files[i];
            cfg_file_parse(cfg, f-&gt;path);
            cfg_file_free(f);
    }
    free(files);

    if (cfg-&gt;searches == NULL)
            cfg_search_add(cfg, &quot;updates&quot;, 0);

    return 0;
}

static void cfg_free(struct cfg *cfg)
{
    while (cfg-&gt;overrides) {
            struct cfg_override *tmp = cfg-&gt;overrides;
            cfg-&gt;overrides = cfg-&gt;overrides-&gt;next;
            cfg_override_free(tmp);
    }

    while (cfg-&gt;searches) {
            struct cfg_search *tmp = cfg-&gt;searches;
            cfg-&gt;searches = cfg-&gt;searches-&gt;next;
            cfg_search_free(tmp);
    }
}</code></pre>
<p>在 depmod.c 文件的实现中，depmod_output 负责最后各类文件的输出功能。</p>
<pre><code>2161 static int depmod_output(struct depmod *depmod, FILE *out)
2162 {
2163         static const struct depfile {
2164                 const char *name;
2165                 int (*cb)(struct depmod *depmod, FILE *out);
2166         } *itr, depfiles[] = {
2167                 { &quot;modules.dep&quot;, output_deps },
2168                 { &quot;modules.dep.bin&quot;, output_deps_bin },
2169                 { &quot;modules.alias&quot;, output_aliases },
2170                 { &quot;modules.alias.bin&quot;, output_aliases_bin },
2171                 { &quot;modules.softdep&quot;, output_softdeps },
2172                 { &quot;modules.symbols&quot;, output_symbols },
2173                 { &quot;modules.symbols.bin&quot;, output_symbols_bin },
2174                 { &quot;modules.builtin.bin&quot;, output_builtin_bin },
2175                 { &quot;modules.devname&quot;, output_devname },
2176                 { }
2177         };</code></pre>
<p>其中输出到 /lib/modules/3.2.0-29-generic-pae/modules.dep 文件的输出函数是 output_deps 通过修改如下 fprintf(out, ...) 函数，增添输出到标准输出 stdout 的 fprintf(stdout, ...) 则可以在屏幕上看到运行 depmod 命令时候的全部输出结果，这个结果和 modules.dep 文件中的内容是完全一样的。</p>
<pre><code>1790 static int output_deps(struct depmod *depmod, FILE *out)
1791 {
1792         size_t i;
1793 
1794         for (i = 0; i &lt; depmod-&gt;modules.count; i++) {
1795                 const struct mod **deps, *mod = depmod-&gt;modules.array[i];
...
1804                 fprintf(out, &quot;%s:&quot;, p);
1805                 fprintf(stdout, &quot;%s:&quot;, p);
...
1824                         fprintf(out, &quot; %s&quot;, mod_get_compressed_path(d));
1825                         fprintf(stdout, &quot; %s&quot;, mod_get_compressed_path(d));
...
1828         end:
1829                 putc(&#39;\n&#39;, out);
1830                 putc(&#39;\n&#39;, stdout);
... 
1834 }</code></pre>
<h3 id="modprobe-命令实现流程">modprobe 命令实现流程</h3>
<p><strong>do_modprobe() 核心代码分析</strong></p>
<pre><code>do_modprobe(int argc, char *argv[])
{
    log_open(use_syslog);

    snprintf(dirname_buf, sizeof(dirname_buf), &quot;%s/lib/modules/%s&quot;, root, kversion);
    dirname = dirname_buf;

    ctx = kmod_new(dirname, config_paths);

    log_setup_kmod_log(ctx, verbose);
    kmod_load_resources(ctx);

    if (do_xxx)
        err = show_config(ctx); 
        err = show_modversions(ctx, args[0]);
        err = insmod_all(ctx, args, nargs);
        err = rmmod_all(ctx, args, nargs); 

    err = options_from_array(args, nargs, &amp;opts);
    err = insmod(ctx, args[0], opts);

    kmod_unref(ctx);

    log_close();
}</code></pre>
<h4 id="insmod_all">insmod_all</h4>
<pre><code>static int insmod_all(struct kmod_ctx *ctx, char **args, int nargs)
{
        for (i = 0; i &lt; nargs; i++) 
        err = insmod(ctx, args[i], NULL);

    return err;
}</code></pre>
<h4 id="insmod">insmod</h4>
<pre><code>-&gt; kmod_module_probe_insert_module()</code></pre>
<h4 id="kmod_module_probe_insert_module">kmod_module_probe_insert_module</h4>
<pre><code>int kmod_module_probe_insert_module(mod, flags, extra_options, run_install)
{
    err = kmod_module_get_probe_list(mod, !!(flags &amp; KMOD_PROBE_IGNORE_COMMAND), &amp;list);

    kmod_list_foreach(l, list) 
    {
        struct kmod_module *m = l-&gt;data;
        err = kmod_module_insert_module(m, flags, options);
    }
}

-&gt; kmod_module_get_probe_list
    -&gt; __kmod_module_get_probe_list
        -&gt; __kmod_module_get_probe_list
            -&gt; kmod_module_get_dependencies
                -&gt;  module_get_dependencies_noref
                    -&gt; kmod_module_parse_depline</code></pre>
<h4 id="kmod_module_get_dependencies">kmod_module_get_dependencies</h4>
<pre><code>kmod_list *kmod_module_get_dependencies(struct kmod_module *mod)
{
    module_get_dependencies_noref(mod);

    kmod_list_foreach(l, mod-&gt;dep)
    {
        l_new = kmod_list_append(list_new, kmod_module_ref(l-&gt;data));
        list_new = l_new;
    }

    return list_new;
}</code></pre>
<h4 id="module_get_dependencies_noref">module_get_dependencies_noref</h4>
<pre><code>kmod_list *module_get_dependencies_noref(struct kmod_module *mod)
{
    char *line = kmod_search_moddep(mod-&gt;ctx, mod-&gt;name);

    kmod_module_parse_depline(mod, line);

    return mod-&gt;dep;
}</code></pre>
<h4 id="kmod_search_moddep">kmod_search_moddep</h4>
<pre><code>char *kmod_search_moddep(struct kmod_ctx *ctx, const char *name)
{
    // name = nfs;      // modprobe nfs
    return index_mm_search(ctx-&gt;indexes[KMOD_INDEX_MODULES_DEP], name);

    DBG(ctx, &quot;file=%s modname=%s\n&quot;, fn, name);

    idx = index_file_open(fn);
    line = index_search(idx, name);
    index_file_close(idx);

    return line;
}</code></pre>
<h4 id="kmod_module_parse_depline">kmod_module_parse_depline</h4>
<pre><code>int kmod_module_parse_depline(struct kmod_module *mod, char *line)
{
    for (p = strtok_r(p, &quot; \t&quot;, &amp;saveptr); p != NULL;
         p = strtok_r(NULL, &quot; \t&quot;, &amp;saveptr)) 
    {
        err = kmod_module_new_from_path(ctx, path, &amp;depmod);
        list = kmod_list_prepend(list, depmod);
        n++;
    }

    mod-&gt;dep = list;
    mod-&gt;n_dep = n;

    return n;
}</code></pre>
<h2 id="函数接口分析">5. 函数接口分析</h2>
<h3 id="kmod_new-核心代码分析">kmod_new() 核心代码分析</h3>
<pre><code>kmod_ctx *kmod_new(char *dirname, char *config_paths)
{
    ctx = calloc(1, sizeof(struct kmod_ctx));
    ctx-&gt;dirname = get_kernel_release(dirname);
    err = kmod_config_new(ctx, &amp;ctx-&gt;config, config_paths);
    ctx-&gt;modules_by_name = hash_new(KMOD_HASH_SIZE, NULL);

    return ctx;
}</code></pre>
<div class="figure">
<img src="./figures/kmod_new.jpg" alt="kmod_new 调用层次图" /><p class="caption">kmod_new 调用层次图</p>
</div>
<h3 id="kmod_unref-核心代码分析">kmod_unref() 核心代码分析</h3>
<pre><code>kmod_ctx *kmod_unref(kmod_ctx *ctx)
{
    kmod_unload_resources(ctx);
    hash_free(ctx-&gt;modules_by_name);
    kmod_config_free(ctx-&gt;config);
    free(ctx);

    return NULL;
}</code></pre>
<div class="figure">
<img src="./figures/kmod_unref.jpg" alt="kmod_unref 调用层次图" /><p class="caption">kmod_unref 调用层次图</p>
</div>
<h3 id="kmod_module_new_from_path-核心代码分析">kmod_module_new_from_path() 核心代码分析</h3>
<pre><code>int kmod_module_new_from_path(kmod_ctx *ctx, char *path, kmod_module **mod)
{
    path_to_modname(path, name, &amp;namelen);
    m = kmod_pool_get_module(ctx, name);
    kmod_module_ref(m);
    err = kmod_module_new(ctx, name, name, namelen, NULL, 0, &amp;m); *
    *mod = m;
    return 0;
}</code></pre>
<div class="figure">
<img src="./figures/kmod_module_new_from_path.jpg" alt="kmod_module_new_from_path 调用层次图" /><p class="caption">kmod_module_new_from_path 调用层次图</p>
</div>
<h3 id="kmod_module_insert_module-核心代码分析">kmod_module_insert_module() 核心代码分析</h3>
<pre><code>int kmod_module_insert_module(kmod_module *mod, int flags, char *options)
{
    path = kmod_module_get_path(mod);
    file = kmod_file_open();
    size = kmod_file_get_size(file);
    mem = kmod_file_get_contents(file);
    elf = kmod_elf_new(mem, size);
    kmod_elf_strip_section(elf);
    mem = kmod_elf_get_memory(elf);
    init_module(mem, size, args);
    kmod_elf_unref(elf);
    kmod_file_unref(file);
}</code></pre>
<div class="figure">
<img src="./figures/kmod_module_insert_module.jpg" alt="kmod_module_insert_module 调用层次图" /><p class="caption">kmod_module_insert_module 调用层次图</p>
</div>
<h3 id="kmod_module_unref-核心代码分析">kmod_module_unref() 核心代码分析</h3>
<pre><code>kmod_module *kmod_module_unref(kmod_module *mod)
{
    --mod-&gt;refcount;

    kmod_pool_del_module(mod-&gt;ctx, mod, mod-&gt;hashkey);
    kmod_module_unref_list(mod-&gt;dep);
    kmod_file_unref(mod-&gt;file);
    kmod_unref(mod-&gt;ctx);

    return NULL;
}</code></pre>
<div class="figure">
<img src="./figures/kmod_module_unref.jpg" alt="kmod_module_unref 调用层次图" /><p class="caption">kmod_module_unref 调用层次图</p>
</div>
<h3 id="init_module-核心代码分析">init_module() 核心代码分析</h3>
<pre><code>long init_module(void *mem, unsigned long len, const char *args)
{
    kmod_elf *elf = kmod_elf_new(mem, len);

    err = kmod_elf_get_section(elf, &quot;.gnu.linkonce.this_module&quot;, &amp;buf, &amp;bufsize);
    kmod_elf_unref(elf);
    mod = find_module(modules, modname);
    if(mod != NULL)
    { 
    } else if (module_is_inkernel(modname))
    {
    } else
        create_sysfs_files(modname);

    return err;
}</code></pre>
<h3 id="do_rmmod-核心代码分析">do_rmmod() 核心代码分析</h3>
<pre><code>do_rmmod(int argc, char *argv[])
{
    flags = argv[x];    // -f, -w, 
    ctx = kmod_new(NULL, &amp;null_config);
    err = kmod_module_new_from_path(ctx, filename, &amp;mod);
    err = kmod_module_remove_module(mod, flags);
    kmod_module_unref(mod);
    kmod_unref(ctx);
}</code></pre>
<h3 id="kmod_module_remove_module-核心代码分析">kmod_module_remove_module() 核心代码分析</h3>
<pre><code>int kmod_module_remove_module(kmod_module *mod, int flags)
{
    err = delete_module(mod-&gt;name, flags);

    return err;
}</code></pre>
<h3 id="delete_module-核心代码分析">delete_module() 核心代码分析</h3>
<pre><code>long init_module(void *mem, int flags)
{
    struct mod *mod;

    mod = find_module(modules, modname);

    return mod-&gt;ret;
}</code></pre>
