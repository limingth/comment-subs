<h1 id="kmod-linux内核模块工具">kmod-Linux内核模块工具</h1>
<h2 id="项目背景分析">1. 项目背景分析</h2>
<p>kmod 是为了能够操作 Linux 内核模块而推出的一系列工具集，这些操作包括 插入（insert），删除（remove），列出（list），检查属性（check properties）和解决依赖关系（dependencies）。</p>
<p>这些工具在底层都需要用到 libkmod 这个库，相关的源码也会跟着 kmod 项目一同发布。这个项目的目标是能够实现与在此之前 module-init-tools 项目所提供的工具兼容。</p>
<h3 id="项目建立时间">项目建立时间</h3>
<p>从 git.kernel.org 上的 commit log 分析，该项目的建立时间是 2011-11-21。最初的项目是通过继承了 libabc 的框架开始逐步演变而来。2011-12-15 发布了 kmod 1 版本。</p>
<p>参考<em>项目主页</em><br /><a href="http://git.kernel.org/cgit/utils/kernel/kmod/kmod.git"><code class="url">http://git.kernel.org/cgit/utils/kernel/kmod/kmod.git</code></a></p>
<h3 id="项目创建者和维护者">项目创建者和维护者</h3>
<p>创建者是 Lucas De Marchi。这个人就职于巴西 Brazil Campinas 的一家公司ProFUSION Embedded Systems（该公司的主页http://profusion.mobi/），从他在 github 个人项目的帐号创建时间看是 2008年10月30号，应该是属于比较早期的 github 用户。</p>
<p>参考<em>个人主页</em><br /><a href="https://github.com/lucasdemarchi"><code class="url">https://github.com/lucasdemarchi</code></a></p>
<h3 id="项目更新记录">项目更新记录</h3>
<p>项目最近一次提交 commit log 表明，该项目近期处于一个比较活跃的状态。从 2013-4-9 发布了最新的 kmod 13 版本之后，该项目几乎每隔1，2天有一次或多次提交。最近的一次提交是 2013-4-17，主要的贡献者仍然是 Lucas De Marchi。</p>
<p>参考<em>提交记录</em><br /><a href="http://git.kernel.org/cgit/utils/kernel/kmod/kmod.git/log/"><code class="url">http://git.kernel.org/cgit/utils/kernel/kmod/kmod.git/log/</code></a></p>
<h3 id="项目版本情况">项目版本情况</h3>
<p>第一个可以下载的软件包 kmod-1.tar.gz 是2012-2-24 上传的，最新的软件包 kmod-13.tar.gz 是 2013-4-9 上传的。</p>
<p>目前 kmod 已经发布到了第13个版本，从项目 NEWS 中可以看到，项目从版本 1 就开始支持原来的 insmod/rmmod/lsmod/modprobe 这几个常用命令，发展至今libkmod 库已经提供了100多个函数接口用于方便用户管理内核模块。</p>
<h3 id="项目资源汇总">项目资源汇总</h3>
<ul>
<li><p>代码下载<br /> <a href="https://www.kernel.org/pub/linux/utils/kernel/kmod"><code class="url">https://www.kernel.org/pub/linux/utils/kernel/kmod</code></a></p></li>
<li><p>邮件列表<br /> <script type="text/javascript">
<!--
h='&#118;&#x67;&#x65;&#114;&#46;&#x6b;&#x65;&#114;&#110;&#x65;&#108;&#46;&#x6f;&#114;&#x67;';a='&#64;';n='&#108;&#x69;&#110;&#x75;&#120;&#x2d;&#x6d;&#x6f;&#100;&#x75;&#108;&#x65;&#x73;';e=n+a+h;
document.write('<a h'+'ref'+'="ma'+'ilto'+':'+e+'">'+'<code>'+e+'</code>'+'<\/'+'a'+'>');
// -->
</script><noscript>&#108;&#x69;&#110;&#x75;&#120;&#x2d;&#x6d;&#x6f;&#100;&#x75;&#108;&#x65;&#x73;&#32;&#x61;&#116;&#32;&#118;&#x67;&#x65;&#114;&#32;&#100;&#x6f;&#116;&#32;&#x6b;&#x65;&#114;&#110;&#x65;&#108;&#32;&#100;&#x6f;&#116;&#32;&#x6f;&#114;&#x67;</noscript></p></li>
<li><p>Git项目仓库<br /> git://git.kernel.org/pub/scm/utils/kernel/kmod/kmod.git<br /> <a href="https://git.kernel.org/pub/scm/utils/kernel/kmod/kmod.git"><code class="url">https://git.kernel.org/pub/scm/utils/kernel/kmod/kmod.git</code></a></p></li>
<li><p>Gitweb页面<br /> <a href="http://git.kernel.org/?p=utils/kernel/kmod/kmod.git"><code class="url">http://git.kernel.org/?p=utils/kernel/kmod/kmod.git</code></a></p></li>
</ul>
<h2 id="项目技术分析">2. 项目技术分析</h2>
<h3 id="开发环境准备">开发环境准备</h3>
<ul>
<li>首先需要安装如下的软件工具
<ul>
<li>GCC compiler 编译工具</li>
<li>GNU C library 标准C库</li>
<li>autoconf 自动化配置工具，可以生成项目所需的 makefile</li>
<li>shtool 一个兼容之前类似 mkdir.sh/install.sh 的shell脚本工具</li>
<li>libtool 制作可生成依赖关系的共享库，生成文件后缀名为 .la, lo</li>
<li>xsltproc 快速XSLT引擎，可以通过XSL层叠样式表把XML转换为其他格式，例如html/pdf</li>
</ul></li>
<li>可选的依赖关系:
<ul>
<li>ZLIB library</li>
<li>LZMA library</li>
</ul></li>
</ul>
<h3 id="编译和安装">编译和安装</h3>
<pre><code>$ sudo apt-get install autoconf 
$ sudo apt-get install shtool 
$ sudo apt-get install libtool
$ sudo apt-get install xsltproc 

$ aclocal
$ autoconf
$ ./configure CFLAGS=&quot;-g -O2&quot; --prefix=/usr --sysconfdir=/etc --libdir=/usr/lib
$ make &amp;&amp; make install</code></pre>
<h3 id="错误及解决">错误及解决</h3>
<p>代码编译过程会出现不少问题，但都可以通过安装和配置逐一解决。现对编译过程中的问题做一总结：</p>
<p><strong>1）autoconf 缺少环境变量文件</strong></p>
<pre><code>$ autoconf 
configure.ac:10: error: possibly undefined macro: AM_INIT_AUTOMAKE
      If this token and others are legitimate, please use m4_pattern_allow.
      See the Autoconf documentation.
configure.ac:28: error: possibly undefined macro: AM_PROG_CC_C_O
configure.ac:89: error: possibly undefined macro: AM_CONDITIONAL
$ aclocal</code></pre>
<p>通过 aclocal 命令生成，获取当前系统的环境变量，生成一个 aclocal.m4 文件。</p>
<p><strong>2）configure 脚本执行时缺少 libtool 工具</strong></p>
<pre><code>$ ./configure CFLAGS=&quot;-g -O2&quot; --prefix=/usr --sysconfdir=/etc --libdir=/usr/lib
configure: error: cannot find install-sh, install.sh, or shtool in build-aux &quot;.&quot;/build-aux
$ autoreconf -f -i -Wall,no-obsolete
Can&#39;t exec &quot;libtoolize&quot;: No such file or directory at /usr/bin/autoreconf line 196.
Use of uninitialized value in pattern match (m//) at /usr/bin/autoreconf line 196.
$ sudo apt-get install libtool</code></pre>
<p>通过 sudo apt-get 安装解决。</p>
<p><strong>3）configuire 脚本执行缺少 xsltproc 命令</strong></p>
<pre><code>$ ./configure CFLAGS=&quot;-g -O2&quot; --prefix=/usr --sysconfdir=/etc --libdir=/usr/lib
configure: error: xsltproc command not found, try ./configure --disable-manpages
$ sudo apt-get install xsltproc </code></pre>
<p>通过 sudo apt-get 安装解决，成功之后，会在当前目录下生成 Makefile 文件。</p>
<h3 id="编译过程">编译过程</h3>
<p>编译过程总体比较顺利，执行 make 和 make install 命令即可完成。</p>
<pre><code>$ make
make --no-print-directory all-recursive
Making all in .
  CC     libkmod/libkmod.lo
  CC     libkmod/libkmod-list.lo
  CC     libkmod/libkmod-config.lo
  CC     libkmod/libkmod-index.lo
  CC     libkmod/libkmod-module.lo
  CC     libkmod/libkmod-file.lo
  CC     libkmod/libkmod-elf.lo
  CC     libkmod/libkmod-signature.lo
  CC     libkmod/libkmod-hash.lo
  CC     libkmod/libkmod-array.lo
  CC     libkmod/libkmod-util.lo
  CCLD   libkmod/libkmod-util.la
  CCLD   libkmod/libkmod.la
  CCLD   libkmod/libkmod-private.la
  CC     tools/kmod.o
  CC     tools/lsmod.o
  CC     tools/rmmod.o
  CC     tools/insmod.o
  CC     tools/modinfo.o
  CC     tools/modprobe.o
  CC     tools/depmod.o
  CC     tools/log.o
  CC     tools/static-nodes.o
  CCLD   tools/kmod
  CCLD   tools/kmod-nolib
  GEN    tools/insmod
  GEN    tools/rmmod
  GEN    tools/lsmod
  GEN    tools/modprobe
  GEN    tools/modinfo
  GEN    tools/depmod
  GEN    libkmod/libkmod.pc
Making all in libkmod/docs
make[2]: Nothing to be done for `all&#39;.
Making all in man
  GEN    depmod.d.5
  GEN    modprobe.d.5
  GEN    modules.dep.5
  GEN    depmod.8
  GEN    insmod.8
  GEN    lsmod.8
  GEN    rmmod.8
  GEN    modprobe.8
  GEN    modinfo.8</code></pre>
<p>由以上编译过程可知，项目主要架构分为2层，上层为 tools 目录下提供的各种工具（兼容之前的命令集，例如 insmod/rmmod），下层为 libkmod 目录下生成的 libkmod.la，为上层工具提供所需要的库函数。</p>
<h3 id="生成文件">生成文件</h3>
<pre><code>$ ls tools/ -l | grep x
lrwxrwxrwx 1 akaedu akaedu     10 Apr 17 04:43 depmod -&gt; kmod-nolib
lrwxrwxrwx 1 akaedu akaedu     10 Apr 17 04:43 insmod -&gt; kmod-nolib
-rwxrwxr-x 1 akaedu akaedu   8385 Apr 17 04:43 kmod
-rwxrwxr-x 1 akaedu akaedu 488644 Apr 17 04:43 kmod-nolib
lrwxrwxrwx 1 akaedu akaedu     10 Apr 17 04:43 lsmod -&gt; kmod-nolib
lrwxrwxrwx 1 akaedu akaedu     10 Apr 17 04:43 modinfo -&gt; kmod-nolib
lrwxrwxrwx 1 akaedu akaedu     10 Apr 17 04:43 modprobe -&gt; kmod-nolib
lrwxrwxrwx 1 akaedu akaedu     10 Apr 17 04:43 rmmod -&gt; kmod-nolib</code></pre>
<p>可以看出以上所有工具，均是 kmod-nolib 的软链接。实现了一个 kmod-nolib 程序，也就实现了之前的各种工具。 这种实现思路，类似于嵌入式开发中的 busybox 项目，也是实现了一堆工具，但只有一个真正的可执行文件。</p>
<pre><code>$ ls libkmod/ -l | grep lo 
-rw-rw-r-- 1 akaedu akaedu   308 Apr 17 04:43 libkmod-array.lo
-rw-rw-r-- 1 akaedu akaedu   310 Apr 17 04:43 libkmod-config.lo
-rw-rw-r-- 1 akaedu akaedu   304 Apr 17 04:43 libkmod-elf.lo
-rw-rw-r-- 1 akaedu akaedu   306 Apr 17 04:43 libkmod-file.lo
-rw-rw-r-- 1 akaedu akaedu   306 Apr 17 04:43 libkmod-hash.lo
-rw-rw-r-- 1 akaedu akaedu   308 Apr 17 04:43 libkmod-index.lo
-rw-rw-r-- 1 akaedu akaedu   306 Apr 17 04:43 libkmod-list.lo
-rw-rw-r-- 1 akaedu akaedu   296 Apr 17 04:43 libkmod.lo
-rw-rw-r-- 1 akaedu akaedu   310 Apr 17 04:43 libkmod-module.lo
-rw-rw-r-- 1 akaedu akaedu   316 Apr 17 04:43 libkmod-signature.lo
-rw-rw-r-- 1 akaedu akaedu   306 Apr 17 04:43 libkmod-util.lo</code></pre>
<p>上面所列的 lo 文件中，libkmod-module.lo 中包含了在整个库中，最靠近上层调用所需要用的接口函数。其他的 lo 文件基本上都是为 libkmod-module.lo 所服务的，比较重要的例如 libkmod-elf, libkmod-file, libkmod-list 等。</p>
<pre><code>$ ls libkmod/ -l | grep la
-rw-rw-r-- 1 akaedu akaedu   923 Apr 17 04:43 libkmod.la
-rw-rw-r-- 1 akaedu akaedu   893 Apr 17 04:43 libkmod-private.la
-rw-rw-r-- 1 akaedu akaedu   884 Apr 17 04:43 libkmod-util.la</code></pre>
<p>最终提供的库文件是以 libkmod.la 的形式存在。</p>
<pre><code>$ ls libkmod/ -l | grep pc
-rw-rw-r-- 1 akaedu akaedu   210 Apr 17 04:43 libkmod.pc
-rw-rw-r-- 1 akaedu akaedu   255 Apr 17 00:53 libkmod.pc.in</code></pre>
<p>此文件暂时没看出有什么特殊的作用，只包含了一些对当前库的说明信息，是一个纯文本文件。</p>
<h3 id="安装过程">安装过程</h3>
<pre><code>$ make &amp;&amp; make install
make --no-print-directory all-recursive
Making all in .
Making all in libkmod/docs
make[2]: Nothing to be done for `all&#39;.
Making all in man
make[2]: Nothing to be done for `all&#39;.
Making install in .
test -z &quot;/usr/lib&quot; || /bin/mkdir -p &quot;/usr/lib&quot;
 /bin/bash ./libtool   --mode=install /usr/bin/install -c   libkmod/libkmod.la &#39;/usr/lib&#39;
libtool: install: /usr/bin/install -c libkmod/.libs/libkmod.so.2.2.3 /usr/lib/libkmod.so.2.2.3
/usr/bin/install: cannot create regular file `/usr/lib/libkmod.so.2.2.3&#39;: Permission denied
make[2]: *** [install-libLTLIBRARIES] Error 1
make[1]: *** [install-am] Error 2
make: *** [install-recursive] Error 1</code></pre>
<p>编译过程中，因为需要用到对 /usr/bin 目录的读写权限，因此需要用 sudo 来执行。</p>
<pre><code>$ sudo make install
Making install in .
test -z &quot;/usr/lib&quot; || /bin/mkdir -p &quot;/usr/lib&quot;
 /bin/bash ./libtool   --mode=install /usr/bin/install -c   libkmod/libkmod.la &#39;/usr/lib&#39;
libtool: install: /usr/bin/install -c libkmod/.libs/libkmod.so.2.2.3 /usr/lib/libkmod.so.2.2.3
libtool: install: (cd /usr/lib &amp;&amp; { ln -s -f libkmod.so.2.2.3 libkmod.so.2 || { rm -f libkmod.so.2 &amp;&amp; ln -s libkmod.so.2.2.3 libkmod.so.2; }; })
libtool: install: (cd /usr/lib &amp;&amp; { ln -s -f libkmod.so.2.2.3 libkmod.so || { rm -f libkmod.so &amp;&amp; ln -s libkmod.so.2.2.3 libkmod.so; }; })
libtool: install: /usr/bin/install -c libkmod/.libs/libkmod.lai /usr/lib/libkmod.la
libtool: finish: PATH=&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/sbin&quot; ldconfig -n /usr/lib
----------------------------------------------------------------------
Libraries have been installed in:
   /usr/lib

If you ever happen to want to link against installed libraries
in a given directory, LIBDIR, you must either use libtool, and
specify the full pathname of the library, or use the `-LLIBDIR&#39;
flag during linking and do at least one of the following:
   - add LIBDIR to the `LD_LIBRARY_PATH&#39; environment variable
     during execution
   - add LIBDIR to the `LD_RUN_PATH&#39; environment variable
     during linking
   - use the `-Wl,-rpath -Wl,LIBDIR&#39; linker flag
   - have your system administrator add LIBDIR to `/etc/ld.so.conf&#39;

See any operating system documentation about shared libraries for
more information, such as the ld(1) and ld.so(8) manual pages.
----------------------------------------------------------------------
test -z &quot;/usr/bin&quot; || /bin/mkdir -p &quot;/usr/bin&quot;
  /bin/bash ./libtool   --mode=install /usr/bin/install -c tools/kmod &#39;/usr/bin&#39;
libtool: install: /usr/bin/install -c tools/.libs/kmod /usr/bin/kmod
make --no-print-directory install-exec-hook
if test &quot;/usr/lib&quot; != &quot;/usr/lib&quot;; then \
        /bin/mkdir -p /usr/lib &amp;&amp; \
        so_img_name=$(readlink /usr/lib/libkmod.so) &amp;&amp; \
        so_img_rel_target_prefix=$(echo /usr/lib | sed &#39;s,\(^/\|\)[^/][^/]*,..,g&#39;) &amp;&amp; \
        ln -sf $so_img_rel_target_prefix/usr/lib/$so_img_name /usr/lib/libkmod.so &amp;&amp; \
        mv /usr/lib/libkmod.so.* /usr/lib; \
    fi
test -z &quot;/usr/include&quot; || /bin/mkdir -p &quot;/usr/include&quot;
 /usr/bin/install -c -m 644 libkmod/libkmod.h &#39;/usr/include&#39;
test -z &quot;/usr/lib/pkgconfig&quot; || /bin/mkdir -p &quot;/usr/lib/pkgconfig&quot;
 /usr/bin/install -c -m 644 libkmod/libkmod.pc &#39;/usr/lib/pkgconfig&#39;
Making install in libkmod/docs
make[2]: Nothing to be done for `install-exec-am&#39;.
make[2]: Nothing to be done for `install-data-am&#39;.
Making install in man
make[2]: Nothing to be done for `install-exec-am&#39;.
test -z &quot;/usr/share/man/man5&quot; || /bin/mkdir -p &quot;/usr/share/man/man5&quot;
 /usr/bin/install -c -m 644 depmod.d.5 modprobe.d.5 modules.dep.5 modules.dep.bin.5 &#39;/usr/share/man/man5&#39;
test -z &quot;/usr/share/man/man8&quot; || /bin/mkdir -p &quot;/usr/share/man/man8&quot;
 /usr/bin/install -c -m 644 depmod.8 insmod.8 lsmod.8 rmmod.8 modprobe.8 modinfo.8 &#39;/usr/share/man/man8&#39;
$ sudo make install</code></pre>
<p>这个 make 和 make install 的过程，帮助我们理清了哪些文件参与最后的编译生成过程。特别是对于最后 make install 的执行分析，也让我们了解了项目最终要实现的目标和生成的重要文件。以下将对这一过程展开详细分析。</p>
<h3 id="安装文件">安装文件</h3>
<pre><code>$ ls /usr/lib/libkmod.so
libkmod.so        libkmod.so.2      libkmod.so.2.2.3  
$ ls /usr/lib/libkmod.so* -l
lrwxrwxrwx 1 root root     16 Apr 17 04:55 /usr/lib/libkmod.so -&gt; libkmod.so.2.2.3
lrwxrwxrwx 1 root root     16 Apr 17 04:55 /usr/lib/libkmod.so.2 -&gt; libkmod.so.2.2.3
-rwxr-xr-x 1 root root 313349 Apr 17 04:55 /usr/lib/libkmod.so.2.2.3</code></pre>
<p>libkmod.so 是一个软链接，安装在系统的 /usr/lib 目录下，链接的时候只需要指定 -lkmod 就可以。</p>
<pre><code>$ ls /usr/lib/libkmod.l* -l
-rwxr-xr-x 1 root root 924 Apr 17 04:55 /usr/lib/libkmod.la

$ ls /usr/lib/libkmod.* -l
-rwxr-xr-x 1 root root    924 Apr 17 04:55 /usr/lib/libkmod.la
lrwxrwxrwx 1 root root     16 Apr 17 04:55 /usr/lib/libkmod.so -&gt; libkmod.so.2.2.3
lrwxrwxrwx 1 root root     16 Apr 17 04:55 /usr/lib/libkmod.so.2 -&gt; libkmod.so.2.2.3
-rwxr-xr-x 1 root root 313349 Apr 17 04:55 /usr/lib/libkmod.so.2.2.3</code></pre>
<p>真正起作用的 so 文件，也就是 libkmod 共享库的 real name 是 libkmod.so.2.2.3。</p>
<pre><code>$ ls /usr/bin/kmod  -l
-rwxr-xr-x 1 root root 233584 Apr 17 04:55 /usr/bin/kmod
$ file /usr/bin/kmod
/usr/bin/kmod: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.24, BuildID[sha1]=0x9d4131d1eb78b1e1852cc5ad44f06417ae3caa3c, not stripped
$ kmod
missing command
kmod - Manage kernel modules: list, load, unload, etc
Usage:
    kmod [options] command [command_options]

Options:
    -V, --version     show version
    -h, --help        show this help

Commands:
  help         Show help message
  list         list currently loaded modules
  static-nodes outputs the static-node information installed with the currently running kernel

kmod also handles gracefully if called from following symlinks:
  lsmod        compat lsmod command
  rmmod        compat rmmod command
  insmod       compat insmod command
  modinfo      compat modinfo command
  modprobe     compat modprobe command
  depmod       compat depmod command</code></pre>
<p>kmod 是一个工具，可以实现内核模块的 list 和 打印输出已经被加载的内核模块的详细信息。</p>
<pre><code>$ ls /usr/include/libkmod.h -l
-rw-r--r-- 1 root root 9429 Apr 17 04:55 /usr/include/libkmod.h
$ 文件内容见下面小节</code></pre>
<p>头文件是最重要的生成文件，会被之后所有调用 libkmod 库的上层应用所包含。一个文件就包含了所有需要用的函数接口声明，使用起来也非常方便。只不过这个文件中包含了较多的函数，互相之间不是平行的，内部是有上下层次关系的。</p>
<pre><code>$ ls /usr/lib/pkgconfig/libkmod.pc -l
-rw-r--r-- 1 root root 210 Apr 17 04:55 /usr/lib/pkgconfig/libkmod.pc
$ cat /usr/lib/pkgconfig/libkmod.pc 
prefix=/usr
exec_prefix=/usr
libdir=/usr/lib
includedir=/usr/include

Name: libkmod
Description: Library to deal with kernel modules
Version: 13
Libs: -L${libdir} -lkmod
Libs.private:  
Cflags: -I${includedir}
$ </code></pre>
<p>这个文件只是一个纯文本文件，里面包含了如上所列出的信息。</p>
<pre><code>$ ls /usr/share/man/man5/ -l | grep &quot;Apr 17&quot;
-rw-r--r-- 1 root root  3969 Apr 17 04:55 depmod.d.5
-rw-r--r-- 1 root root  9306 Apr 17  2012 fonts-conf.5.gz
-rw-r--r-- 1 root root  1599 Apr 17  2012 initramfs.conf.5.gz
-rw-r--r-- 1 root root  8059 Apr 17 04:55 modprobe.d.5
-rw-r--r-- 1 root root  2494 Apr 17 04:55 modules.dep.5
-rw-r--r-- 1 root root    18 Apr 17 04:55 modules.dep.bin.5
-rw-r--r-- 1 root root   585 Apr 17  2012 update-initramfs.conf.5.gz
$ ls /usr/share/man/man8/ -l | grep &quot;Apr 17&quot;
-rw-r--r-- 1 root root  6398 Apr 17 04:55 depmod.8
-rw-r--r-- 1 root root  5170 Apr 17  2012 initramfs-tools.8.gz
-rw-r--r-- 1 root root  2151 Apr 17 04:55 insmod.8
-rw-r--r-- 1 root root   526 Apr 17  2012 lsinitramfs.8.gz
-rw-r--r-- 1 root root  1839 Apr 17 04:55 lsmod.8
-rw-r--r-- 1 root root  1570 Apr 17  2012 mkinitramfs.8.gz
-rw-r--r-- 1 root root  4009 Apr 17 04:55 modinfo.8
-rw-r--r-- 1 root root 10618 Apr 17 04:55 modprobe.8
-rw-r--r-- 1 root root  3058 Apr 17 04:55 rmmod.8
-rw-r--r-- 1 root root  1016 Apr 17  2012 update-initramfs.8.gz</code></pre>
<p>以上所有文件，均为 man 手册所准备的，通过 make install 将安装到系统路径 /usr/share/man/man8 下。</p>
<h3 id="功能简介">功能简介</h3>
<ul>
<li>libkmod.so
<ul>
<li>kmod 库的共享库文件，用于动态链接。</li>
</ul></li>
<li>libkmod.la
<ul>
<li>用 libtool 工具生成的库文件，其实就是一个文本文件，记录同名共享库的相关信息</li>
<li>libtool 工具的作用，是在编译大型软件的过程中解决了库的依赖问题。</li>
<li>特别是在交叉编译的条件下，解决动态链接器如何去寻找共享库的问题。</li>
</ul></li>
<li>kmod
<ul>
<li>一个管理内核模块的工具，提供列表list，加载load，卸载unload等功能。</li>
<li>目前的版本似乎只支持 help, list, static_nodes 三条命令</li>
<li>help 列出帮助信息</li>
<li>list 列出当前加载模块</li>
<li>static-nodes 输出当前内核加载的 static-node 信息，包括设备节点文件名，类型，主设备号和次设备号。</li>
</ul></li>
<li>libkmod.h
<ul>
<li>使用 libkmod 库所需要包含的头文件，详细接口定义见下节--项目代码分析。</li>
</ul></li>
<li>libkmod.pc
<ul>
<li>文本文件，包含了使用 libkmod 库所需要了解的一些信息，例如 安装目录，头文件所在目录，库名称，描述等。</li>
</ul></li>
<li>man5 &amp; man8
<ul>
<li>提供通过类似 man 8 insmod 命令来查看帮助的源文件 inssmod.8</li>
<li>提供通过类似 man 5 depmod.d 命令来查看帮助的源文件 depmod.d.5</li>
</ul></li>
</ul>
<h2 id="项目代码分析">3. 项目代码分析</h2>
<h3 id="源码目录结构">源码目录结构</h3>
<ul>
<li>tools
<ul>
<li>insmod.c</li>
<li>rmmod.c</li>
<li>lsmod.c</li>
<li>depmod.c</li>
<li>modinfo.c</li>
<li>modprobe.c</li>
<li>kmod.c</li>
<li>kmod.h</li>
<li>log.c</li>
<li>log.h</li>
<li>static-nodes.c</li>
</ul></li>
<li>libkmod
<ul>
<li>COPYING</li>
<li>docs</li>
<li>libkmod-array.c</li>
<li>libkmod-array.h</li>
<li>libkmod.c</li>
<li>libkmod-config.c</li>
<li>libkmod-elf.c</li>
<li>libkmod-file.c</li>
<li>libkmod.h</li>
<li>libkmod-hash.c</li>
<li>libkmod-hash.h</li>
<li>libkmod-index.c</li>
<li>libkmod-index.h</li>
<li>libkmod-list.c</li>
<li>libkmod-module.c</li>
<li>libkmod.pc.in</li>
<li>libkmod-private.h</li>
<li>libkmod-signature.c</li>
<li>libkmod.sym</li>
<li>libkmod-util.c</li>
<li>libkmod-util.h</li>
<li>macro.h</li>
<li>missing.h</li>
<li>README</li>
</ul></li>
<li>testsuite
<ul>
<li>COPYING</li>
<li>delete_module.c</li>
<li>init_module.c</li>
<li>mkdir.c</li>
<li>mkdir.h</li>
<li>path.c</li>
<li>README</li>
<li>rootfs-pristine</li>
<li>stripped-module.h</li>
<li>test-alias.c</li>
<li>test-blacklist.c</li>
<li>test-dependencies.c</li>
<li>test-depmod.c</li>
<li>test-init.c</li>
<li>test-loaded.c</li>
<li>test-modinfo.c</li>
<li>test-modprobe.c</li>
<li>test-new-module.c</li>
<li>testsuite.c</li>
<li>testsuite.h</li>
<li>test-testsuite.c</li>
<li>uname.c</li>
</ul></li>
<li>m4
<ul>
<li>attributes.m4</li>
</ul></li>
<li>man
<ul>
<li>depmod.d.xml</li>
<li>depmod.xml</li>
<li>insmod.xml</li>
<li>lsmod.xml</li>
<li>Makefile.am</li>
<li>modinfo.xml</li>
<li>modprobe.d.xml</li>
<li>modprobe.xml</li>
<li>modules.dep.xml</li>
<li>rmmod.xml</li>
</ul></li>
</ul>
<h3 id="头文件分析">头文件分析</h3>
<pre><code>$ cat /usr/include/libkmod.h 

/*
 * libkmod - interface to kernel module operations
 *
 * Copyright (C) 2011-2013  ProFUSION embedded systems
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */

#pragma once
#ifndef _LIBKMOD_H_
#define _LIBKMOD_H_

#include &lt;fcntl.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;inttypes.h&gt;

#ifdef __cplusplus
extern &quot;C&quot; {
#endif

/*
 * kmod_ctx
 *
 * library user context - reads the config and system
 * environment, user variables, allows custom logging
 */
struct kmod_ctx;
struct kmod_ctx *kmod_new(const char *dirname, const char * const *config_paths);
struct kmod_ctx *kmod_ref(struct kmod_ctx *ctx);
struct kmod_ctx *kmod_unref(struct kmod_ctx *ctx);
void kmod_set_log_fn(struct kmod_ctx *ctx,
            void (*log_fn)(void *log_data,
                    int priority, const char *file, int line,
                    const char *fn, const char *format,
                    va_list args),
            const void *data);
int kmod_get_log_priority(const struct kmod_ctx *ctx);
void kmod_set_log_priority(struct kmod_ctx *ctx, int priority);
void *kmod_get_userdata(const struct kmod_ctx *ctx);
void kmod_set_userdata(struct kmod_ctx *ctx, const void *userdata);


/*
 * Management of libkmod&#39;s resources
 */
int kmod_load_resources(struct kmod_ctx *ctx);
void kmod_unload_resources(struct kmod_ctx *ctx);

enum kmod_resources {
    KMOD_RESOURCES_OK = 0,
    KMOD_RESOURCES_MUST_RELOAD = 1,
    KMOD_RESOURCES_MUST_RECREATE = 2,
};
int kmod_validate_resources(struct kmod_ctx *ctx);

enum kmod_index {
    KMOD_INDEX_MODULES_DEP = 0,
    KMOD_INDEX_MODULES_ALIAS,
    KMOD_INDEX_MODULES_SYMBOL,
    KMOD_INDEX_MODULES_BUILTIN,
    /* Padding to make sure enum is not mapped to char */
    _KMOD_INDEX_PAD = (1 &lt;&lt; 31),
};
int kmod_dump_index(struct kmod_ctx *ctx, enum kmod_index type, int fd);

/*
 * kmod_list
 *
 * access to kmod generated lists
 */
struct kmod_list;
struct kmod_list *kmod_list_next(const struct kmod_list *list,
                        const struct kmod_list *curr);
struct kmod_list *kmod_list_prev(const struct kmod_list *list,
                        const struct kmod_list *curr);
struct kmod_list *kmod_list_last(const struct kmod_list *list);

#define kmod_list_foreach(list_entry, first_entry) \
    for (list_entry = first_entry; \
        list_entry != NULL; \
        list_entry = kmod_list_next(first_entry, list_entry))

#define kmod_list_foreach_reverse(list_entry, first_entry) \
    for (list_entry = kmod_list_last(first_entry); \
        list_entry != NULL; \
        list_entry = kmod_list_prev(first_entry, list_entry))

/*
 * kmod_config_iter
 *
 * access to configuration lists - it allows to get each configuration&#39;s
 * key/value stored by kmod
 */
struct kmod_config_iter;
struct kmod_config_iter *kmod_config_get_blacklists(const struct kmod_ctx *ctx);
struct kmod_config_iter *kmod_config_get_install_commands(const struct kmod_ctx *ctx);
struct kmod_config_iter *kmod_config_get_remove_commands(const struct kmod_ctx *ctx);
struct kmod_config_iter *kmod_config_get_aliases(const struct kmod_ctx *ctx);
struct kmod_config_iter *kmod_config_get_options(const struct kmod_ctx *ctx);
struct kmod_config_iter *kmod_config_get_softdeps(const struct kmod_ctx *ctx);
const char *kmod_config_iter_get_key(const struct kmod_config_iter *iter);
const char *kmod_config_iter_get_value(const struct kmod_config_iter *iter);
bool kmod_config_iter_next(struct kmod_config_iter *iter);
void kmod_config_iter_free_iter(struct kmod_config_iter *iter);

/*
 * kmod_module
 *
 * Operate on kernel modules
 */
struct kmod_module;
int kmod_module_new_from_name(struct kmod_ctx *ctx, const char *name,
                        struct kmod_module **mod);
int kmod_module_new_from_path(struct kmod_ctx *ctx, const char *path,
                        struct kmod_module **mod);
int kmod_module_new_from_lookup(struct kmod_ctx *ctx, const char *given_alias,
                        struct kmod_list **list);
int kmod_module_new_from_loaded(struct kmod_ctx *ctx,
                        struct kmod_list **list);

struct kmod_module *kmod_module_ref(struct kmod_module *mod);
struct kmod_module *kmod_module_unref(struct kmod_module *mod);
int kmod_module_unref_list(struct kmod_list *list);
struct kmod_module *kmod_module_get_module(const struct kmod_list *entry);


/* Removal flags */
enum kmod_remove {
    KMOD_REMOVE_FORCE = O_TRUNC,
    KMOD_REMOVE_NOWAIT = O_NONBLOCK,
};

/* Insertion flags */
enum kmod_insert {
    KMOD_INSERT_FORCE_VERMAGIC = 0x1,
    KMOD_INSERT_FORCE_MODVERSION = 0x2,
};

/* Flags to kmod_module_probe_insert_module() */
enum kmod_probe {
    KMOD_PROBE_FORCE_VERMAGIC =     0x00001,
    KMOD_PROBE_FORCE_MODVERSION =       0x00002,
    KMOD_PROBE_IGNORE_COMMAND =     0x00004,
    KMOD_PROBE_IGNORE_LOADED =      0x00008,
    KMOD_PROBE_DRY_RUN =            0x00010,
    KMOD_PROBE_FAIL_ON_LOADED =     0x00020,

    /* codes below can be used in return value, too */
    KMOD_PROBE_APPLY_BLACKLIST_ALL =    0x10000,
    KMOD_PROBE_APPLY_BLACKLIST =        0x20000,
    KMOD_PROBE_APPLY_BLACKLIST_ALIAS_ONLY = 0x40000,
};

/* Flags to kmod_module_apply_filter() */
enum kmod_filter {
    KMOD_FILTER_BLACKLIST = 0x00001,
    KMOD_FILTER_BUILTIN = 0x00002,
};

int kmod_module_remove_module(struct kmod_module *mod, unsigned int flags);
int kmod_module_insert_module(struct kmod_module *mod, unsigned int flags,
                            const char *options);
int kmod_module_probe_insert_module(struct kmod_module *mod,
            unsigned int flags, const char *extra_options,
            int (*run_install)(struct kmod_module *m,
                        const char *cmdline, void *data),
            const void *data,
            void (*print_action)(struct kmod_module *m, bool install,
                        const char *options));


const char *kmod_module_get_name(const struct kmod_module *mod);
const char *kmod_module_get_path(const struct kmod_module *mod);
const char *kmod_module_get_options(const struct kmod_module *mod);
const char *kmod_module_get_install_commands(const struct kmod_module *mod);
const char *kmod_module_get_remove_commands(const struct kmod_module *mod);
struct kmod_list *kmod_module_get_dependencies(const struct kmod_module *mod);
int kmod_module_get_softdeps(const struct kmod_module *mod,
                struct kmod_list **pre, struct kmod_list **post);
int kmod_module_get_filtered_blacklist(const struct kmod_ctx *ctx,
                    const struct kmod_list *input,
                    struct kmod_list **output) __attribute__ ((deprecated));
int kmod_module_apply_filter(const struct kmod_ctx *ctx,
                    enum kmod_filter filter_type,
                    const struct kmod_list *input,
                    struct kmod_list **output);



/*
 * Information regarding &quot;live information&quot; from module&#39;s state, as returned
 * by kernel
 */

enum kmod_module_initstate {
    KMOD_MODULE_BUILTIN = 0,
    KMOD_MODULE_LIVE,
    KMOD_MODULE_COMING,
    KMOD_MODULE_GOING,
    /* Padding to make sure enum is not mapped to char */
    _KMOD_MODULE_PAD = (1 &lt;&lt; 31),
};
const char *kmod_module_initstate_str(enum kmod_module_initstate state);
int kmod_module_get_initstate(const struct kmod_module *mod);
int kmod_module_get_refcnt(const struct kmod_module *mod);
struct kmod_list *kmod_module_get_holders(const struct kmod_module *mod);
struct kmod_list *kmod_module_get_sections(const struct kmod_module *mod);
const char *kmod_module_section_get_name(const struct kmod_list *entry);
unsigned long kmod_module_section_get_address(const struct kmod_list *entry);
void kmod_module_section_free_list(struct kmod_list *list);
long kmod_module_get_size(const struct kmod_module *mod);



/*
 * Information retrieved from ELF headers and sections
 */

int kmod_module_get_info(const struct kmod_module *mod, struct kmod_list **list);
const char *kmod_module_info_get_key(const struct kmod_list *entry);
const char *kmod_module_info_get_value(const struct kmod_list *entry);
void kmod_module_info_free_list(struct kmod_list *list);

int kmod_module_get_versions(const struct kmod_module *mod, struct kmod_list **list);
const char *kmod_module_version_get_symbol(const struct kmod_list *entry);
uint64_t kmod_module_version_get_crc(const struct kmod_list *entry);
void kmod_module_versions_free_list(struct kmod_list *list);

int kmod_module_get_symbols(const struct kmod_module *mod, struct kmod_list **list);
const char *kmod_module_symbol_get_symbol(const struct kmod_list *entry);
uint64_t kmod_module_symbol_get_crc(const struct kmod_list *entry);
void kmod_module_symbols_free_list(struct kmod_list *list);

enum kmod_symbol_bind {
    KMOD_SYMBOL_NONE = &#39;\0&#39;,
    KMOD_SYMBOL_LOCAL = &#39;L&#39;,
    KMOD_SYMBOL_GLOBAL = &#39;G&#39;,
    KMOD_SYMBOL_WEAK = &#39;W&#39;,
    KMOD_SYMBOL_UNDEF = &#39;U&#39;
};

int kmod_module_get_dependency_symbols(const struct kmod_module *mod, struct kmod_list **list);
const char *kmod_module_dependency_symbol_get_symbol(const struct kmod_list *entry);
int kmod_module_dependency_symbol_get_bind(const struct kmod_list *entry);
uint64_t kmod_module_dependency_symbol_get_crc(const struct kmod_list *entry);
void kmod_module_dependency_symbols_free_list(struct kmod_list *list);

#ifdef __cplusplus
} /* extern &quot;C&quot; */
#endif
#endif
$ </code></pre>
<ul>
<li>头文件是 libkmod 项目所提供的用于包含的函数调用接口，上层编程者一般都需要 include 这个文件。</li>
<li>以 insmod 命令实现为例，以下函数接口将会用于这个命令实现过程中，典型的调用用法如下：
<ul>
<li>kmod_new()</li>
<li>kmod_module_new_from_path()</li>
<li>kmod_module_insert_module()</li>
<li>kmod_module_unref()</li>
</ul></li>
</ul>
<h3 id="数据结构设计">数据结构设计</h3>
<ul>
<li>struct kmod_ctx
<ul>
<li>该结构体出现在 libkmod/libkmod.c 文件中</li>
<li>用于读取配置和系统环境参数，用户参数等</li>
</ul></li>
</ul>
<p>结构体定义</p>
<pre><code>/**
 * kmod_ctx:
 *
 * Opaque object representing the library context.
 */
struct kmod_ctx {
    int refcount;
    int log_priority;
    void (*log_fn)(void *data,
                    int priority, const char *file, int line,
                    const char *fn, const char *format, va_list args);
    void *log_data;
    const void *userdata;
    char *dirname;
    struct kmod_config *config;
    struct hash *modules_by_name;
    struct index_mm *indexes[_KMOD_INDEX_MODULES_SIZE];
    unsigned long long indexes_stamp[_KMOD_INDEX_MODULES_SIZE];
};</code></pre>
<ul>
<li>struct kmod_list
<ul>
<li>该结构体出现在 libkmod/libkmod-private.h 文件中</li>
<li>用于访问 kmod 产生的模块节点链表</li>
</ul></li>
</ul>
<p>结构体定义</p>
<pre><code>struct list_node {
    struct list_node *next, *prev;
};

struct kmod_list {
    struct list_node node;
    void *data;
};</code></pre>
<ul>
<li>struct kmod_config_iter
<ul>
<li>该结构体出现在 libkmod/libkmod-config.c 文件中</li>
</ul></li>
</ul>
<p>结构体定义</p>
<pre><code>struct kmod_config_iter {
    enum config_type type;
    bool intermediate;
    const struct kmod_list *list;
    const struct kmod_list *curr;
    void *data;
    const char *(*get_key)(const struct kmod_list *l); 
    const char *(*get_value)(const struct kmod_list *l); 
};</code></pre>
<ul>
<li>struct kmod_module
<ul>
<li>该结构体出现在 libkmod/libkmod-module.c 文件中</li>
</ul></li>
</ul>
<p>结构体定义</p>
<pre><code>/**
 * SECTION:libkmod-module
 * @short_description: operate on kernel modules
 */

/**
 * kmod_module:
 *
 * Opaque object representing a module.
 */
struct kmod_module {
    struct kmod_ctx *ctx;
    char *hashkey;
    char *name;
    char *path;
    struct kmod_list *dep;
    char *options;
    const char *install_commands;   /* owned by kmod_config */
    const char *remove_commands;    /* owned by kmod_config */
    char *alias; /* only set if this module was created from an alias */
    struct kmod_file *file;
    int n_dep;
    int refcount;
    struct {
        bool dep : 1;
        bool options : 1;
        bool install_commands : 1;
        bool remove_commands : 1;
    } init;

    /*
     * private field used by kmod_module_get_probe_list() to detect
     * dependency loops
     */
    bool visited : 1;

    /*
     * set by kmod_module_get_probe_list: indicates for probe_insert()
     * whether the module&#39;s command and softdep should be ignored
     */
    bool ignorecmd : 1;

    /*
     * if module was created by searching the modules.builtin file, this
     * is set. There&#39;s nothing much useful one can do with such a
     * &quot;module&quot;, except knowing it&#39;s builtin.
     */
    bool builtin : 1;
};</code></pre>
<h3 id="重要接口实现">重要接口实现</h3>
<ul>
<li>kmod_module_insert_module() in libkmod/libkmod-module.c
<ul>
<li>kmod_module_get_path()</li>
<li>file = kmod_file_open()</li>
<li>kmod_file_get_direct()</li>
<li>size = kmod_file_get_size(file)</li>
<li>mem = kmod_file_get_contents(file)</li>
<li>kmod_elf_new()</li>
<li>kmod_elf_strip_section()</li>
<li>kmod_elf_get_memory()</li>
<li>init_module(mem, size, args)</li>
<li>kmod_elf_unref()</li>
<li>kmod_file_unref()</li>
</ul></li>
<li>对比 module-init-tools 的实现，可以发现代码的层次逻辑复杂不少
<ul>
<li>realloc()</li>
<li>grab_file()
<ul>
<li>open()</li>
<li>malloc()</li>
<li>read()</li>
<li>close()</li>
</ul></li>
<li>init_module(file, len, options)</li>
<li>free()</li>
</ul></li>
<li>kmod_module_remove_module in libkmod/libkmod-module.c
<ul>
<li>delete_module()</li>
</ul></li>
</ul>
<h1 id="kmod-11-详细分析报告">kmod-11 详细分析报告</h1>
<h2 id="架构分析">1. 架构分析</h2>
<p>kmod 项目的整个架构分为 3 层。最底层是 testsuite, 中间是 libkmod, 上层是 tools</p>
<h3 id="应用层">应用层</h3>
<h3 id="中间层">中间层</h3>
<h3 id="抽象层">抽象层</h3>
<h2 id="模块分析">2. 模块分析</h2>
<h3 id="kmod_module">kmod_module</h3>
<h3 id="kmod_elf">kmod_elf</h3>
<h3 id="kmod_file">kmod_file</h3>
<h3 id="kmod_ctx">kmod_ctx</h3>
<h3 id="kmod_config">kmod_config</h3>
<h3 id="kmod_list">kmod_list</h3>
<h3 id="index_mm">index_mm</h3>
<h3 id="elf">elf</h3>
<h3 id="hash">hash</h3>
<h3 id="list">list</h3>
<h3 id="array">array</h3>
<h3 id="log">log</h3>
<h2 id="函数接口分析">3. 函数接口分析</h2>
<h2 id="运行流程分析">4. 运行流程分析</h2>
<h3 id="insmod-实现流程">insmod 实现流程</h3>
<pre><code>$ sudo ./kmod-11/tools/rmmod hello-module/hello.ko 
$ lsmod | grep hello
$ sudo ./kmod-11/tools/insmod hello-module/hello.ko 
$ lsmod | grep hello
hello                  12415  0 
$ sudo ./kmod-11/tools/insmod hello-module/hello.ko 
insmod: ERROR: could not insert module hello-module/hello.ko: File exists
$ lsmod | grep hello
hello                  12415  0 
$ sudo ./kmod-11/tools/rmmod hello-module/hello.ko 
$ lsmod | grep hello
$ </code></pre>
<h4 id="核心代码">核心代码</h4>
<pre><code>ctx = kmod_new(NULL, &amp;null_config);
err = kmod_module_new_from_path(ctx, filename, &amp;mod);
err = kmod_module_insert_module(mod, 0, opts);
kmod_module_unref(mod);
kmod_unref(ctx);</code></pre>
<p>insmod 命令的实现可以分为5个步骤</p>
<ul>
<li>创建模块的上下文 struct kmod_ctx ctx</li>
<li>通过 filename 和 ctx 获得模块 struct kmod_module mod</li>
<li>将 mod 插入到当前模块列表中, 完成真正的插入内核功能</li>
<li>释放 mod</li>
<li>释放 ctx</li>
</ul>
<p>涉及到两个模块的5个接口，两个模块是</p>
<ul>
<li>libkmod/libkmod.c
<ul>
<li>kmod_new()</li>
<li>kmod_unref()</li>
</ul></li>
<li>libkmod/libkmod-module.c
<ul>
<li>kmod_module_new_from_path()</li>
<li>kmod_module_insert_module()</li>
<li>kmod_module_unref()</li>
</ul></li>
</ul>
<h4 id="kmod_new-代码分析">kmod_new 代码分析</h4>
<h4 id="kmod_unref-代码分析">kmod_unref 代码分析</h4>
<h4 id="kmod_module_new_from_path-代码分析">kmod_module_new_from_path 代码分析</h4>
<h4 id="kmod_module_insert_module-代码分析">kmod_module_insert_module 代码分析</h4>
<h4 id="kmod_module_unref-代码分析">kmod_module_unref 代码分析</h4>
<h3 id="rmsmod-实现流程">rmsmod 实现流程</h3>
<h3 id="lsmod-实现流程">lsmod 实现流程</h3>
<h3 id="modinfo-实现流程">modinfo 实现流程</h3>
<h3 id="depmod-实现流程">depmod 实现流程</h3>
<h3 id="modprobe-实现流程">modprobe 实现流程</h3>
